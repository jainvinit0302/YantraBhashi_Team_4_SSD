{"ast":null,"code":"class YantraBhashiValidator {\n  constructor() {\n    this.variables = new Map();\n    this.errors = [];\n    this.reservedWords = [\n      // Add your reserved words here if any\n    ];\n    this.DATA_TYPES = ['ANKHE', 'VARTTAI'];\n    this.scopeStack = [new Map()];\n    this.bracketStack = [];\n  }\n  preprocessCode(code) {\n    const pipeFormatted = this.jsonToPipeSeparatedString(code);\n    return this.tokenize(pipeFormatted, '|').map(line => line.trim()).filter(line => line && !line.startsWith('#')).map(line => line.replace(/^\\d+\\.\\s*/, ''));\n  }\n  jsonToPipeSeparatedString(programText) {\n    if (typeof programText !== 'string' || programText.length === 0) {\n      return \"\";\n    }\n    return programText.replace(/\\n/g, '|');\n  }\n  tokenize(input, del) {\n    let token = [];\n    let left = 0;\n    let right = 0;\n    while (left < input.length) {\n      if (left == right && input[left] == del) {\n        left++;\n        continue;\n      }\n      right = left + 1;\n      while (right < input.length && input[right] != del) {\n        right++;\n      }\n      token.push(input.substring(left, right));\n      left = right;\n    }\n    return token;\n  }\n  validate(code) {\n    this.variables.clear();\n    this.errors = [];\n    this.scopeStack = [new Map()];\n    this.bracketStack = [];\n    const lines = this.preprocessCode(code);\n    let flag = true;\n    for (let i = 0; i < lines.length; i++) {\n      let result = this.ece_cmd(lines[i].trim());\n      if (result.status !== \"next\") {\n        this.addError(i + 1, result.error);\n        flag = false;\n      }\n    }\n    if (flag && this.bracketStack.length !== 0) {\n      this.addError(-1, \"Unclosed block. Missing one or more ']' characters.\");\n      flag = false;\n    }\n    return {\n      isValid: this.errors.length === 0,\n      errors: this.errors\n    };\n  }\n  enterScope() {\n    this.scopeStack.push(new Map());\n  }\n  exitScope() {\n    if (this.scopeStack.length > 1) {\n      this.scopeStack.pop();\n    }\n  }\n  declare(variableName, info) {\n    const currentScope = this.scopeStack[this.scopeStack.length - 1];\n    if (currentScope.has(variableName)) {\n      return {\n        success: false,\n        error: `Semantic Error: Variable '${variableName}' has already been declared in this scope.`\n      };\n    }\n    currentScope.set(variableName, info);\n    return {\n      success: true\n    };\n  }\n  lookup(variableName) {\n    for (let i = this.scopeStack.length - 1; i >= 0; i--) {\n      if (this.scopeStack[i].has(variableName)) {\n        return this.scopeStack[i].get(variableName);\n      }\n    }\n    return null;\n  }\n  hasSemicolon(line) {\n    if (typeof line !== 'string') {\n      return false;\n    }\n    return line.trim().endsWith(';');\n  }\n  getExpressionType(expression) {\n    const trimmedExpr = expression.trim();\n    if (/^\\d+$/.test(trimmedExpr)) return {\n      success: true,\n      type: 'ANKHE'\n    };\n    if (/^\"[^\"]*\"?$/.test(trimmedExpr)) return {\n      success: true,\n      type: 'VARTTAI'\n    };\n    const variableInfo = this.lookup(trimmedExpr);\n    if (variableInfo) return {\n      success: true,\n      type: variableInfo.type\n    };\n    return {\n      success: false,\n      error: `Semantic Error: Variable '${trimmedExpr}' was used before it was declared.`\n    };\n  }\n  validatePadam(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith('PADAM ')) {\n      return {\n        status: 'NOT_PADAM'\n      };\n    }\n    const padamRegex = /^\\s*PADAM\\s+(?<variable>[a-zA-Z_]\\w*)\\s*:\\s*(?<type>ANKHE|VARTTAI)(?:\\s*=\\s*(?<value>\\d+|\"[^\"]*\"))?\\s*;\\s*$/;\n    const match = trimmedLine.match(padamRegex);\n    if (!match) {\n      if (!this.hasSemicolon(line)) {\n        return {\n          status: 'INVALID_SYNTAX',\n          error: \"Missing semicolon (;) at the end of the PADAM statement.\"\n        };\n      }\n      return {\n        status: 'INVALID_SYNTAX',\n        error: \"Syntax error in PADAM declaration.\"\n      };\n    }\n    const {\n      variable,\n      type,\n      value\n    } = match.groups;\n    if (value !== undefined) {\n      const isStringValue = value.startsWith('\"');\n      if (type === 'ANKHE' && isStringValue) {\n        return {\n          status: 'SEMANTIC_ERROR',\n          error: `Type Mismatch: Cannot assign a VARTTAI (string) to an ANKHE (integer) variable '${variable}'.`\n        };\n      }\n      if (type === 'VARTTAI' && !isStringValue) {\n        return {\n          status: 'SEMANTIC_ERROR',\n          error: `Type Mismatch: Cannot assign an ANKHE (integer) to a VARTTAI (string) variable '${variable}'.`\n        };\n      }\n      return {\n        status: 'VALID',\n        type: 'initialization',\n        data: {\n          variable,\n          type,\n          value\n        }\n      };\n    } else {\n      return {\n        status: 'VALID',\n        type: 'declaration',\n        data: {\n          variable,\n          type,\n          value: undefined\n        }\n      };\n    }\n  }\n  validateCheppu(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith('CHEPPU')) {\n      return {\n        status: 'NOT_CHEPPU'\n      };\n    }\n    const cheppuRegex = /^\\s*CHEPPU\\s*\\(\\s*(?<variable>[a-zA-Z_]\\w*)\\s*\\)\\s*;\\s*$/;\n    const match = trimmedLine.match(cheppuRegex);\n    if (!match) {\n      if (!this.hasSemicolon(line)) {\n        return {\n          status: 'INVALID_SYNTAX',\n          error: \"Missing semicolon (;) at the end of the CHEPPU statement.\"\n        };\n      }\n      return {\n        status: 'INVALID_SYNTAX',\n        error: \"Syntax error in CHEPPU statement. Expected format: CHEPPU(variable);\"\n      };\n    }\n    const {\n      variable\n    } = match.groups;\n    const variableInfo = this.lookup(variable);\n    if (variableInfo === null) {\n      return {\n        status: 'SEMANTIC_ERROR',\n        error: `Undeclared Variable: Cannot get input for '${variable}' because it has not been declared.`\n      };\n    }\n    return {\n      status: 'VALID',\n      data: {\n        command: 'CHEPPU',\n        variable: variable\n      }\n    };\n  }\n  validateAssignment(line) {\n    const trimmedLine = line.trim();\n    if (!/(?<![=<>!])=(?![=])/.test(trimmedLine)) {\n      return {\n        status: 'NOT_ASSIGNMENT'\n      };\n    }\n    const assignRegex = /^\\s*(?<lhsVar>[a-zA-Z_]\\w*)\\s*=\\s*(?<rhsExpr>.*);\\s*$/;\n    const match = trimmedLine.match(assignRegex);\n    if (!match) {\n      if (!this.hasSemicolon(line)) {\n        return {\n          status: 'INVALID_SYNTAX',\n          error: \"Missing semicolon (;) at the end of the assignment statement.\"\n        };\n      }\n      return {\n        status: 'INVALID_SYNTAX',\n        error: \"Invalid syntax for assignment statement.\"\n      };\n    }\n    const {\n      lhsVar,\n      rhsExpr\n    } = match.groups;\n    const lhsInfo = this.lookup(lhsVar);\n    if (!lhsInfo) {\n      return {\n        status: 'SEMANTIC_ERROR',\n        error: `Undeclared variable '${lhsVar}' used in assignment.`\n      };\n    }\n    let rhsType;\n    const operators = ['+', '-', '*', '/'];\n    const foundOperator = operators.find(op => rhsExpr.includes(op));\n    if (foundOperator) {\n      const parts = rhsExpr.split(foundOperator);\n      if (parts.length !== 2) {\n        return {\n          status: 'INVALID_SYNTAX',\n          error: 'Malformed expression. Only simple binary operations are supported.'\n        };\n      }\n      const leftResult = this.getExpressionType(parts[0]);\n      const rightResult = this.getExpressionType(parts[1]);\n      if (!leftResult.success) return {\n        status: 'SEMANTIC_ERROR',\n        error: leftResult.error\n      };\n      if (!rightResult.success) return {\n        status: 'SEMANTIC_ERROR',\n        error: rightResult.error\n      };\n      if (leftResult.type === 'ANKHE' && rightResult.type === 'ANKHE') {\n        rhsType = 'ANKHE';\n      } else {\n        return {\n          status: 'SEMANTIC_ERROR',\n          error: `Type Mismatch: Operator '${foundOperator}' can only be used between two ANKHE types.`\n        };\n      }\n    } else {\n      const result = this.getExpressionType(rhsExpr);\n      if (!result.success) return {\n        status: 'SEMANTIC_ERROR',\n        error: result.error\n      };\n      rhsType = result.type;\n    }\n    if (lhsInfo.type !== rhsType) {\n      return {\n        status: 'SEMANTIC_ERROR',\n        error: `Type Mismatch: Cannot assign a value of type ${rhsType} to variable '${lhsVar}' of type ${lhsInfo.type}.`\n      };\n    }\n    return {\n      status: 'VALID'\n    };\n  }\n  validateChatimpu(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith('CHATIMPU')) {\n      return {\n        status: 'NOT_CHATIMPU'\n      };\n    }\n    const chatimpuRegex = /^\\s*CHATIMPU\\s*\\(\\s*(?<argument>\"(?:\\\\.|[^\"\\\\])*\"|[a-zA-Z_]\\w*)\\s*\\)\\s*;\\s*$/;\n    const match = trimmedLine.match(chatimpuRegex);\n    if (!match) {\n      if (!this.hasSemicolon(line)) {\n        return {\n          status: 'INVALID_SYNTAX',\n          error: \"Missing semicolon (;) at the end of the CHATIMPU statement.\"\n        };\n      }\n      return {\n        status: 'INVALID_SYNTAX',\n        error: \"Syntax error in CHATIMPU. Expected format: CHATIMPU(variable_or_literal);\"\n      };\n    }\n    const {\n      argument\n    } = match.groups;\n    if (argument.startsWith('\"')) {\n      return {\n        status: 'VALID',\n        data: {\n          type: 'literal',\n          value: argument\n        }\n      };\n    } else {\n      if (this.lookup(argument) === null) {\n        return {\n          status: 'SEMANTIC_ERROR',\n          error: `Undeclared Variable: Cannot print '${argument}' because it has not been declared.`\n        };\n      }\n      return {\n        status: 'VALID',\n        data: {\n          type: 'variable',\n          name: argument\n        }\n      };\n    }\n  }\n  validateElaitheHeader(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith('ELAITHE')) {\n      return {\n        status: 'NOT_ELAITHE'\n      };\n    }\n    const headerRegex = /^\\s*ELAITHE\\s*\\(\\s*(?<operand1>\\S+)\\s*(?<operator>==|!=|<=|>=|<|>)\\s*(?<operand2>\\S+)\\s*\\)\\s*\\[\\s*$/;\n    const match = trimmedLine.match(headerRegex);\n    if (!match) {\n      return {\n        status: 'INVALID_SYNTAX',\n        error: \"Syntax error in ELAITHE header. Expected: ELAITHE (value operator value) [\"\n      };\n    }\n    const {\n      operand1,\n      operator,\n      operand2\n    } = match.groups;\n    const op1Result = this.getExpressionType(operand1);\n    const op2Result = this.getExpressionType(operand2);\n    if (!op1Result.success) return {\n      status: 'SEMANTIC_ERROR',\n      error: op1Result.error\n    };\n    if (!op2Result.success) return {\n      status: 'SEMANTIC_ERROR',\n      error: op2Result.error\n    };\n    if (op1Result.type !== op2Result.type) {\n      return {\n        status: 'SEMANTIC_ERROR',\n        error: `Type Mismatch: Cannot compare type ${op1Result.type} with type ${op2Result.type} in condition.`\n      };\n    }\n    return {\n      status: 'VALID'\n    };\n  }\n  validateBlockEnd(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith(']')) {\n      return {\n        status: 'NOT_A_BLOCK_END'\n      };\n    }\n    const elseRegex = /^\\s*]\\s*ALAITHE\\s*\\[\\s*$/;\n    if (elseRegex.test(trimmedLine)) {\n      return {\n        status: 'VALID',\n        data: {\n          type: 'end_with_else'\n        }\n      };\n    }\n    const endOnlyRegex = /^\\s*]\\s*$/;\n    if (endOnlyRegex.test(trimmedLine)) {\n      return {\n        status: 'VALID',\n        data: {\n          type: 'end_only'\n        }\n      };\n    }\n    return {\n      status: 'INVALID_SYNTAX',\n      error: \"Malformed block-closing statement. Expected ']' or '] ALAITHE ['.\"\n    };\n  }\n  validateMalliMalliHeader(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith('MALLI-MALLI')) {\n      return {\n        status: 'NOT_MALLI_MALLI'\n      };\n    }\n    const mainRegex = /^\\s*MALLI-MALLI\\s*\\((?<content>.*)\\)\\s*\\[\\s*$/;\n    const mainMatch = trimmedLine.match(mainRegex);\n    if (!mainMatch) {\n      return {\n        status: 'INVALID_SYNTAX',\n        error: \"Malformed MALLI-MALLI structure. Expected: MALLI-MALLI (...) [\"\n      };\n    }\n    const parts = mainMatch.groups.content.split(';').map(p => p.trim());\n    if (parts.length !== 3) {\n      return {\n        status: 'INVALID_SYNTAX',\n        error: \"MALLI-MALLI loop requires three parts: initialization; condition; update.\"\n      };\n    }\n    const initPart = parts[0];\n    const padamRegex = /^\\s*PADAM\\s+(?<variable>[a-zA-Z_]\\w*)\\s*:\\s*(?<type>ANKHE)\\s*=\\s*(?<value>\\d+)\\s*$/;\n    const initMatch = initPart.match(padamRegex);\n    if (!initMatch) {\n      return {\n        status: 'SEMANTIC_ERROR',\n        error: \"Loop initialization must be a PADAM statement initializing an ANKHE variable (e.g., PADAM i:ANKHE = 0).\"\n      };\n    }\n    const loopVarInfo = initMatch.groups;\n    const loopVariableName = loopVarInfo.variable;\n    const internalLookup = varName => {\n      if (varName === loopVariableName) return {\n        type: 'ANKHE'\n      };\n      return this.lookup(varName);\n    };\n    const determineType = expr => {\n      if (/^\\d+$/.test(expr.trim())) return {\n        success: true,\n        type: 'ANKHE'\n      };\n      const result = internalLookup(expr.trim());\n      if (result) return {\n        success: true,\n        type: result.type\n      };\n      return {\n        success: false,\n        error: `Undeclared variable '${expr}' in loop condition.`\n      };\n    };\n    const condPart = parts[1];\n    const condRegex = /^\\s*(?<op1>\\S+)\\s*(?<op>==|!=|<=|>=|<|>)\\s*(?<op2>\\S+)\\s*$/;\n    const condMatch = condPart.match(condRegex);\n    if (!condMatch) return {\n      status: 'INVALID_SYNTAX',\n      error: `Malformed loop condition: \"${condPart}\".`\n    };\n    const op1Result = determineType(condMatch.groups.op1);\n    const op2Result = determineType(condMatch.groups.op2);\n    if (!op1Result.success) return {\n      status: 'SEMANTIC_ERROR',\n      error: op1Result.error\n    };\n    if (!op2Result.success) return {\n      status: 'SEMANTIC_ERROR',\n      error: op2Result.error\n    };\n    if (op1Result.type !== 'ANKHE' || op2Result.type !== 'ANKHE') {\n      return {\n        status: 'SEMANTIC_ERROR',\n        error: `Loop condition must compare two ANKHE types.`\n      };\n    }\n    const updatePart = parts[2];\n    const updateRegex = /^\\s*(?<lhs>\\S+)\\s*=\\s*(?<rhs>\\S+)\\s*([+-])\\s*1\\s*$/;\n    const updateMatch = updatePart.match(updateRegex);\n    if (!updateMatch || updateMatch.groups.lhs !== loopVariableName || updateMatch.groups.rhs !== loopVariableName) {\n      return {\n        status: 'SEMANTIC_ERROR',\n        error: `Loop update must be of the form '${loopVariableName} = ${loopVariableName} + 1'.`\n      };\n    }\n    return {\n      status: 'VALID',\n      data: {\n        variable: loopVarInfo.variable,\n        type: loopVarInfo.type,\n        value: loopVarInfo.value\n      }\n    };\n  }\n  ece_cmd(command) {\n    const validationOrder = [this.validatePadam, this.validateCheppu, this.validateChatimpu, this.validateElaitheHeader, this.validateMalliMalliHeader, this.validateBlockEnd, this.validateAssignment];\n    for (const validator of validationOrder) {\n      const result = validator.call(this, command);\n      if (result.status === \"VALID\") {\n        if (validator === this.validateElaitheHeader) {\n          this.enterScope();\n          this.bracketStack.push(1);\n        } else if (validator === this.validateMalliMalliHeader) {\n          this.enterScope();\n          const declareResult = this.declare(result.data.variable, {\n            type: result.data.type,\n            value: result.data.value\n          });\n          if (!declareResult.success) {\n            return {\n              status: 'SEMANTIC_ERROR',\n              error: declareResult.error\n            };\n          }\n          this.bracketStack.push(3);\n        } else if (validator === this.validateBlockEnd) {\n          if (this.bracketStack.length === 0) return {\n            status: \"Error\",\n            error: \"Closing bracket ']' has no matching opening block.\"\n          };\n          this.exitScope();\n          if (result.data.type === \"end_with_else\") {\n            this.enterScope();\n            if (this.bracketStack.length === 0 || this.bracketStack.pop() !== 1) return {\n              status: \"Error\",\n              error: \"'ALAITHE' must follow an 'ELAITHE' block.\"\n            };\n            this.bracketStack.push(2);\n          } else {\n            this.bracketStack.pop();\n          }\n        } else if (validator === this.validatePadam) {\n          const declareResult = this.declare(result.data.variable, {\n            type: result.data.type,\n            value: result.data.value\n          });\n          if (!declareResult.success) {\n            return {\n              status: 'SEMANTIC_ERROR',\n              error: declareResult.error\n            };\n          }\n        }\n        return {\n          status: \"next\"\n        };\n      }\n      if (result.status === \"SEMANTIC_ERROR\") {\n        if (validator === this.validateElaitheHeader || validator === this.validateMalliMalliHeader) {\n          this.enterScope();\n          if (validator === this.validateElaitheHeader) {\n            this.bracketStack.push(1);\n          } else {\n            this.bracketStack.push(3);\n          }\n        }\n        return result;\n      }\n      if (result.status === \"INVALID_SYNTAX\") {\n        return result;\n      }\n    }\n    return {\n      status: \"Error\",\n      error: \"Invalid or unrecognized syntax\"\n    };\n  }\n  addError(lineNum, message) {\n    this.errors.push({\n      line: lineNum,\n      message\n    });\n  }\n}\nexport default YantraBhashiValidator;","map":{"version":3,"names":["YantraBhashiValidator","constructor","variables","Map","errors","reservedWords","DATA_TYPES","scopeStack","bracketStack","preprocessCode","code","pipeFormatted","jsonToPipeSeparatedString","tokenize","map","line","trim","filter","startsWith","replace","programText","length","input","del","token","left","right","push","substring","validate","clear","lines","flag","i","result","ece_cmd","status","addError","error","isValid","enterScope","exitScope","pop","declare","variableName","info","currentScope","has","success","set","lookup","get","hasSemicolon","endsWith","getExpressionType","expression","trimmedExpr","test","type","variableInfo","validatePadam","trimmedLine","padamRegex","match","variable","value","groups","undefined","isStringValue","data","validateCheppu","cheppuRegex","command","validateAssignment","assignRegex","lhsVar","rhsExpr","lhsInfo","rhsType","operators","foundOperator","find","op","includes","parts","split","leftResult","rightResult","validateChatimpu","chatimpuRegex","argument","name","validateElaitheHeader","headerRegex","operand1","operator","operand2","op1Result","op2Result","validateBlockEnd","elseRegex","endOnlyRegex","validateMalliMalliHeader","mainRegex","mainMatch","content","p","initPart","initMatch","loopVarInfo","loopVariableName","internalLookup","varName","determineType","expr","condPart","condRegex","condMatch","op1","op2","updatePart","updateRegex","updateMatch","lhs","rhs","validationOrder","validator","call","declareResult","lineNum","message"],"sources":["/home/batman/Desktop/NO_Brainer/YantraBhashi_Team_4_SSD/frontend/src/services/validator.js"],"sourcesContent":["class YantraBhashiValidator {\n  constructor() {\n    this.variables = new Map();\n    this.errors = [];\n    this.reservedWords = [\n      // Add your reserved words here if any\n    ];\n    this.DATA_TYPES = ['ANKHE', 'VARTTAI'];\n    this.scopeStack = [new Map()];\n    this.bracketStack = [];\n  }\n\n  preprocessCode(code) {\n    const pipeFormatted = this.jsonToPipeSeparatedString(code);\n    return this.tokenize(pipeFormatted, '|')\n      .map(line => line.trim())\n      .filter(line => line && !line.startsWith('#'))\n      .map(line => line.replace(/^\\d+\\.\\s*/, ''));\n  }\n\n  jsonToPipeSeparatedString(programText) {\n    if (typeof programText !== 'string' || programText.length === 0) {\n      return \"\";\n    }\n    return programText.replace(/\\n/g, '|');\n  }\n\n  tokenize(input, del) {\n    let token = [];\n    let left = 0;\n    let right = 0;\n    while (left < input.length) {\n      if (left == right && input[left] == del) {\n        left++;\n        continue;\n      }\n      right = left + 1;\n      while (right < input.length && input[right] != del) {\n        right++;\n      }\n      token.push(input.substring(left, right));\n      left = right;\n    }\n    return token;\n  }\n\n  validate(code) {\n    this.variables.clear();\n    this.errors = [];\n    this.scopeStack = [new Map()];\n    this.bracketStack = [];\n\n    const lines = this.preprocessCode(code);\n    let flag = true;\n\n    for (let i = 0; i < lines.length; i++) {\n      let result = this.ece_cmd(lines[i].trim());\n      if (result.status !== \"next\") {\n        this.addError(i + 1, result.error);\n        flag = false;\n      }\n    }\n\n    if (flag && this.bracketStack.length !== 0) {\n      this.addError(-1, \"Unclosed block. Missing one or more ']' characters.\");\n      flag = false;\n    }\n\n    return {\n      isValid: this.errors.length === 0,\n      errors: this.errors,\n    };\n  }\n\n  enterScope() {\n    this.scopeStack.push(new Map());\n  }\n\n  exitScope() {\n    if (this.scopeStack.length > 1) {\n      this.scopeStack.pop();\n    }\n  }\n\n  declare(variableName, info) {\n    const currentScope = this.scopeStack[this.scopeStack.length - 1];\n    if (currentScope.has(variableName)) {\n      return { success: false, error: `Semantic Error: Variable '${variableName}' has already been declared in this scope.` };\n    }\n    currentScope.set(variableName, info);\n    return { success: true };\n  }\n\n  lookup(variableName) {\n    for (let i = this.scopeStack.length - 1; i >= 0; i--) {\n      if (this.scopeStack[i].has(variableName)) {\n        return this.scopeStack[i].get(variableName);\n      }\n    }\n    return null;\n  }\n\n  hasSemicolon(line) {\n    if (typeof line !== 'string') {\n      return false;\n    }\n    return line.trim().endsWith(';');\n  }\n\n  getExpressionType(expression) {\n    const trimmedExpr = expression.trim();\n    if (/^\\d+$/.test(trimmedExpr)) return { success: true, type: 'ANKHE' };\n    if (/^\"[^\"]*\"?$/.test(trimmedExpr)) return { success: true, type: 'VARTTAI' };\n    const variableInfo = this.lookup(trimmedExpr);\n    if (variableInfo) return { success: true, type: variableInfo.type };\n    return { success: false, error: `Semantic Error: Variable '${trimmedExpr}' was used before it was declared.` };\n  }\n\n  validatePadam(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith('PADAM ')) {\n      return { status: 'NOT_PADAM' };\n    }\n    const padamRegex = /^\\s*PADAM\\s+(?<variable>[a-zA-Z_]\\w*)\\s*:\\s*(?<type>ANKHE|VARTTAI)(?:\\s*=\\s*(?<value>\\d+|\"[^\"]*\"))?\\s*;\\s*$/;\n    const match = trimmedLine.match(padamRegex);\n    if (!match) {\n      if (!this.hasSemicolon(line)) {\n        return { status: 'INVALID_SYNTAX', error: \"Missing semicolon (;) at the end of the PADAM statement.\" };\n      }\n      return { status: 'INVALID_SYNTAX', error: \"Syntax error in PADAM declaration.\" };\n    }\n    const { variable, type, value } = match.groups;\n    if (value !== undefined) {\n      const isStringValue = value.startsWith('\"');\n      if (type === 'ANKHE' && isStringValue) {\n        return { status: 'SEMANTIC_ERROR', error: `Type Mismatch: Cannot assign a VARTTAI (string) to an ANKHE (integer) variable '${variable}'.` };\n      }\n      if (type === 'VARTTAI' && !isStringValue) {\n        return { status: 'SEMANTIC_ERROR', error: `Type Mismatch: Cannot assign an ANKHE (integer) to a VARTTAI (string) variable '${variable}'.` };\n      }\n      return { status: 'VALID', type: 'initialization', data: { variable, type, value } };\n    } else {\n      return { status: 'VALID', type: 'declaration', data: { variable, type, value: undefined } };\n    }\n  }\n\n  validateCheppu(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith('CHEPPU')) {\n      return { status: 'NOT_CHEPPU' };\n    }\n    const cheppuRegex = /^\\s*CHEPPU\\s*\\(\\s*(?<variable>[a-zA-Z_]\\w*)\\s*\\)\\s*;\\s*$/;\n    const match = trimmedLine.match(cheppuRegex);\n    if (!match) {\n      if (!this.hasSemicolon(line)) {\n        return { status: 'INVALID_SYNTAX', error: \"Missing semicolon (;) at the end of the CHEPPU statement.\" };\n      }\n      return { status: 'INVALID_SYNTAX', error: \"Syntax error in CHEPPU statement. Expected format: CHEPPU(variable);\" };\n    }\n    const { variable } = match.groups;\n    const variableInfo = this.lookup(variable);\n    if (variableInfo === null) {\n      return { status: 'SEMANTIC_ERROR', error: `Undeclared Variable: Cannot get input for '${variable}' because it has not been declared.` };\n    }\n    return { status: 'VALID', data: { command: 'CHEPPU', variable: variable } };\n  }\n\n  validateAssignment(line) {\n    const trimmedLine = line.trim();\n    if (!/(?<![=<>!])=(?![=])/.test(trimmedLine)) {\n      return { status: 'NOT_ASSIGNMENT' };\n    }\n    const assignRegex = /^\\s*(?<lhsVar>[a-zA-Z_]\\w*)\\s*=\\s*(?<rhsExpr>.*);\\s*$/;\n    const match = trimmedLine.match(assignRegex);\n    if (!match) {\n      if (!this.hasSemicolon(line)) {\n        return { status: 'INVALID_SYNTAX', error: \"Missing semicolon (;) at the end of the assignment statement.\" };\n      }\n      return { status: 'INVALID_SYNTAX', error: \"Invalid syntax for assignment statement.\" };\n    }\n    const { lhsVar, rhsExpr } = match.groups;\n    const lhsInfo = this.lookup(lhsVar);\n    if (!lhsInfo) {\n      return { status: 'SEMANTIC_ERROR', error: `Undeclared variable '${lhsVar}' used in assignment.` };\n    }\n    let rhsType;\n    const operators = ['+', '-', '*', '/'];\n    const foundOperator = operators.find(op => rhsExpr.includes(op));\n    if (foundOperator) {\n      const parts = rhsExpr.split(foundOperator);\n      if (parts.length !== 2) {\n        return { status: 'INVALID_SYNTAX', error: 'Malformed expression. Only simple binary operations are supported.' };\n      }\n      const leftResult = this.getExpressionType(parts[0]);\n      const rightResult = this.getExpressionType(parts[1]);\n      if (!leftResult.success) return { status: 'SEMANTIC_ERROR', error: leftResult.error };\n      if (!rightResult.success) return { status: 'SEMANTIC_ERROR', error: rightResult.error };\n      if (leftResult.type === 'ANKHE' && rightResult.type === 'ANKHE') {\n        rhsType = 'ANKHE';\n      } else {\n        return { status: 'SEMANTIC_ERROR', error: `Type Mismatch: Operator '${foundOperator}' can only be used between two ANKHE types.` };\n      }\n    } else {\n      const result = this.getExpressionType(rhsExpr);\n      if (!result.success) return { status: 'SEMANTIC_ERROR', error: result.error };\n      rhsType = result.type;\n    }\n    if (lhsInfo.type !== rhsType) {\n      return { status: 'SEMANTIC_ERROR', error: `Type Mismatch: Cannot assign a value of type ${rhsType} to variable '${lhsVar}' of type ${lhsInfo.type}.` };\n    }\n    return { status: 'VALID' };\n  }\n\n  validateChatimpu(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith('CHATIMPU')) {\n      return { status: 'NOT_CHATIMPU' };\n    }\n    const chatimpuRegex = /^\\s*CHATIMPU\\s*\\(\\s*(?<argument>\"(?:\\\\.|[^\"\\\\])*\"|[a-zA-Z_]\\w*)\\s*\\)\\s*;\\s*$/;\n    const match = trimmedLine.match(chatimpuRegex);\n    if (!match) {\n      if (!this.hasSemicolon(line)) {\n        return { status: 'INVALID_SYNTAX', error: \"Missing semicolon (;) at the end of the CHATIMPU statement.\" };\n      }\n      return { status: 'INVALID_SYNTAX', error: \"Syntax error in CHATIMPU. Expected format: CHATIMPU(variable_or_literal);\" };\n    }\n    const { argument } = match.groups;\n    if (argument.startsWith('\"')) {\n      return { status: 'VALID', data: { type: 'literal', value: argument } };\n    } else {\n      if (this.lookup(argument) === null) {\n        return { status: 'SEMANTIC_ERROR', error: `Undeclared Variable: Cannot print '${argument}' because it has not been declared.` };\n      }\n      return { status: 'VALID', data: { type: 'variable', name: argument } };\n    }\n  }\n\n  validateElaitheHeader(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith('ELAITHE')) {\n      return { status: 'NOT_ELAITHE' };\n    }\n    const headerRegex = /^\\s*ELAITHE\\s*\\(\\s*(?<operand1>\\S+)\\s*(?<operator>==|!=|<=|>=|<|>)\\s*(?<operand2>\\S+)\\s*\\)\\s*\\[\\s*$/;\n    const match = trimmedLine.match(headerRegex);\n    if (!match) {\n      return { status: 'INVALID_SYNTAX', error: \"Syntax error in ELAITHE header. Expected: ELAITHE (value operator value) [\" };\n    }\n    const { operand1, operator, operand2 } = match.groups;\n    const op1Result = this.getExpressionType(operand1);\n    const op2Result = this.getExpressionType(operand2);\n    if (!op1Result.success) return { status: 'SEMANTIC_ERROR', error: op1Result.error };\n    if (!op2Result.success) return { status: 'SEMANTIC_ERROR', error: op2Result.error };\n    if (op1Result.type !== op2Result.type) {\n      return { status: 'SEMANTIC_ERROR', error: `Type Mismatch: Cannot compare type ${op1Result.type} with type ${op2Result.type} in condition.` };\n    }\n    return { status: 'VALID' };\n  }\n\n  validateBlockEnd(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith(']')) {\n      return { status: 'NOT_A_BLOCK_END' };\n    }\n    const elseRegex = /^\\s*]\\s*ALAITHE\\s*\\[\\s*$/;\n    if (elseRegex.test(trimmedLine)) {\n      return { status: 'VALID', data: { type: 'end_with_else' } };\n    }\n    const endOnlyRegex = /^\\s*]\\s*$/;\n    if (endOnlyRegex.test(trimmedLine)) {\n      return { status: 'VALID', data: { type: 'end_only' } };\n    }\n    return { status: 'INVALID_SYNTAX', error: \"Malformed block-closing statement. Expected ']' or '] ALAITHE ['.\" };\n  }\n\n  validateMalliMalliHeader(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith('MALLI-MALLI')) {\n      return { status: 'NOT_MALLI_MALLI' };\n    }\n    const mainRegex = /^\\s*MALLI-MALLI\\s*\\((?<content>.*)\\)\\s*\\[\\s*$/;\n    const mainMatch = trimmedLine.match(mainRegex);\n    if (!mainMatch) {\n      return { status: 'INVALID_SYNTAX', error: \"Malformed MALLI-MALLI structure. Expected: MALLI-MALLI (...) [\" };\n    }\n    const parts = mainMatch.groups.content.split(';').map(p => p.trim());\n    if (parts.length !== 3) {\n      return { status: 'INVALID_SYNTAX', error: \"MALLI-MALLI loop requires three parts: initialization; condition; update.\" };\n    }\n    const initPart = parts[0];\n    const padamRegex = /^\\s*PADAM\\s+(?<variable>[a-zA-Z_]\\w*)\\s*:\\s*(?<type>ANKHE)\\s*=\\s*(?<value>\\d+)\\s*$/;\n    const initMatch = initPart.match(padamRegex);\n    if (!initMatch) {\n      return { status: 'SEMANTIC_ERROR', error: \"Loop initialization must be a PADAM statement initializing an ANKHE variable (e.g., PADAM i:ANKHE = 0).\" };\n    }\n    const loopVarInfo = initMatch.groups;\n    const loopVariableName = loopVarInfo.variable;\n    const internalLookup = (varName) => {\n      if (varName === loopVariableName) return { type: 'ANKHE' };\n      return this.lookup(varName);\n    };\n    const determineType = (expr) => {\n      if (/^\\d+$/.test(expr.trim())) return { success: true, type: 'ANKHE' };\n      const result = internalLookup(expr.trim());\n      if (result) return { success: true, type: result.type };\n      return { success: false, error: `Undeclared variable '${expr}' in loop condition.` };\n    };\n    const condPart = parts[1];\n    const condRegex = /^\\s*(?<op1>\\S+)\\s*(?<op>==|!=|<=|>=|<|>)\\s*(?<op2>\\S+)\\s*$/;\n    const condMatch = condPart.match(condRegex);\n    if (!condMatch) return { status: 'INVALID_SYNTAX', error: `Malformed loop condition: \"${condPart}\".` };\n    const op1Result = determineType(condMatch.groups.op1);\n    const op2Result = determineType(condMatch.groups.op2);\n    if (!op1Result.success) return { status: 'SEMANTIC_ERROR', error: op1Result.error };\n    if (!op2Result.success) return { status: 'SEMANTIC_ERROR', error: op2Result.error };\n    if (op1Result.type !== 'ANKHE' || op2Result.type !== 'ANKHE') {\n      return { status: 'SEMANTIC_ERROR', error: `Loop condition must compare two ANKHE types.` };\n    }\n    const updatePart = parts[2];\n    const updateRegex = /^\\s*(?<lhs>\\S+)\\s*=\\s*(?<rhs>\\S+)\\s*([+-])\\s*1\\s*$/;\n    const updateMatch = updatePart.match(updateRegex);\n    if (!updateMatch || updateMatch.groups.lhs !== loopVariableName || updateMatch.groups.rhs !== loopVariableName) {\n      return { status: 'SEMANTIC_ERROR', error: `Loop update must be of the form '${loopVariableName} = ${loopVariableName} + 1'.` };\n    }\n    return { status: 'VALID', data: { variable: loopVarInfo.variable, type: loopVarInfo.type, value: loopVarInfo.value } };\n  }\n\n  ece_cmd(command) {\n    const validationOrder = [\n      this.validatePadam,\n      this.validateCheppu,\n      this.validateChatimpu,\n      this.validateElaitheHeader,\n      this.validateMalliMalliHeader,\n      this.validateBlockEnd,\n      this.validateAssignment\n    ];\n    for (const validator of validationOrder) {\n      const result = validator.call(this, command);\n      if (result.status === \"VALID\") {\n        if (validator === this.validateElaitheHeader) {\n          this.enterScope();\n          this.bracketStack.push(1);\n        } else if (validator === this.validateMalliMalliHeader) {\n          this.enterScope();\n          const declareResult = this.declare(result.data.variable, { type: result.data.type, value: result.data.value });\n          if (!declareResult.success) {\n            return { status: 'SEMANTIC_ERROR', error: declareResult.error };\n          }\n          this.bracketStack.push(3);\n        } else if (validator === this.validateBlockEnd) {\n          if (this.bracketStack.length === 0) return { status: \"Error\", error: \"Closing bracket ']' has no matching opening block.\" };\n          this.exitScope();\n          if (result.data.type === \"end_with_else\") {\n            this.enterScope();\n            if (this.bracketStack.length === 0 || this.bracketStack.pop() !== 1) return { status: \"Error\", error: \"'ALAITHE' must follow an 'ELAITHE' block.\" };\n            this.bracketStack.push(2);\n          } else {\n            this.bracketStack.pop();\n          }\n        } else if (validator === this.validatePadam) {\n          const declareResult = this.declare(result.data.variable, { type: result.data.type, value: result.data.value });\n          if (!declareResult.success) {\n            return { status: 'SEMANTIC_ERROR', error: declareResult.error };\n          }\n        }\n        return { status: \"next\" };\n      }\n      if (result.status === \"SEMANTIC_ERROR\") {\n        if (validator === this.validateElaitheHeader || validator === this.validateMalliMalliHeader) {\n          this.enterScope();\n          if (validator === this.validateElaitheHeader) {\n            this.bracketStack.push(1);\n          } else {\n            this.bracketStack.push(3);\n          }\n        }\n        return result;\n      }\n      if (result.status === \"INVALID_SYNTAX\") {\n        return result;\n      }\n    }\n    return { status: \"Error\", error: \"Invalid or unrecognized syntax\" };\n  }\n\n  addError(lineNum, message) {\n    this.errors.push({ line: lineNum, message });\n  }\n}\n\nexport default YantraBhashiValidator;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}