{"ast":null,"code":"var _jsxFileName = \"/home/batman/Desktop/NO_Brainer/YantraBhashi_Team_4_SSD/frontend/src/components/compiler/CompilerInterface.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from 'react';\nimport Header from '../common/Header';\nimport CodeEditor from './CodeEditor';\nimport OutputPanel from './OutputPanel';\nimport YantraBhashiValidator from '../../services/validator';\nimport mockAPI from '../../services/mockAPI';\nimport '../../styles/components.css';\n\n// Inline interpreter class\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nclass YantraBhashiInterpreter {\n  constructor() {\n    this.scopeStack = [new Map()];\n    this.output = [];\n  }\n  enterScope() {\n    this.scopeStack.push(new Map());\n  }\n  exitScope() {\n    if (this.scopeStack.length > 1) {\n      this.scopeStack.pop();\n    }\n  }\n  declare(name, info) {\n    const scope = this.scopeStack[this.scopeStack.length - 1];\n    if (scope.has(name)) {\n      return {\n        success: false,\n        error: `Variable '${name}' already declared.`\n      };\n    }\n    scope.set(name, info);\n    return {\n      success: true\n    };\n  }\n  lookup(name) {\n    for (let i = this.scopeStack.length - 1; i >= 0; i--) {\n      if (this.scopeStack[i].has(name)) {\n        return this.scopeStack[i].get(name);\n      }\n    }\n    return null;\n  }\n  update(name, value) {\n    for (let i = this.scopeStack.length - 1; i >= 0; i--) {\n      if (this.scopeStack[i].has(name)) {\n        const info = this.scopeStack[i].get(name);\n        info.value = value;\n        return {\n          success: true\n        };\n      }\n    }\n    return {\n      success: false,\n      error: `Variable '${name}' not found.`\n    };\n  }\n  validatePadam(line) {\n    const match = line.trim().match(/^\\s*PADAM\\s+(?<variable>[a-zA-Z_]\\w*)\\s*:\\s*(?<type>ANKHE|VARTTAI)(?:\\s*=\\s*(?<value>.+))?\\s*;\\s*$/);\n    if (!match) return {\n      status: 'INVALID_SYNTAX'\n    };\n    return {\n      status: 'VALID',\n      data: match.groups\n    };\n  }\n  validateChatimpu(line) {\n    const match = line.trim().match(/^\\s*CHATIMPU\\s*\\(\\s*(?<argument>.*)\\s*\\)\\s*;\\s*$/);\n    if (!match) return {\n      status: 'INVALID_SYNTAX'\n    };\n    const arg = match.groups.argument.trim();\n    return {\n      status: 'VALID',\n      data: arg.startsWith('\"') ? {\n        value: arg\n      } : {\n        name: arg\n      }\n    };\n  }\n  validateCheppu(line) {\n    const match = line.trim().match(/^\\s*CHEPPU\\s*\\(\\s*(?<variable>[a-zA-Z_]\\w*)\\s*\\)\\s*;\\s*$/);\n    if (!match) return {\n      status: 'INVALID_SYNTAX'\n    };\n    return {\n      status: 'VALID',\n      data: match.groups\n    };\n  }\n  analyzeBlockStructure(lines) {\n    const blockInfoList = [];\n    const blockStack = [];\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      const entry = {\n        lineNumber: i,\n        lineText: line,\n        elseBodyStartLine: null\n      };\n      if (line.startsWith('ELAITHE')) {\n        entry.type = 'ELAITHE';\n        blockInfoList.push(entry);\n        blockStack.push(entry);\n      } else if (line.startsWith('MALLI-MALLI')) {\n        entry.type = 'MALLI_MALLI';\n        blockInfoList.push(entry);\n        blockStack.push(entry);\n      } else if (line.startsWith('] ALAITHE [')) {\n        entry.type = 'ELSE';\n        blockInfoList.push(entry);\n        const currentBlock = blockStack[blockStack.length - 1];\n        if (currentBlock && currentBlock.type === 'ELAITHE') {\n          currentBlock.elseBodyStartLine = i;\n        }\n      } else if (line === ']') {\n        entry.type = 'BLOCK_END';\n        blockInfoList.push(entry);\n        if (blockStack.length > 0) {\n          const finishedBlock = blockStack.pop();\n          finishedBlock.constructEndLine = i;\n        }\n      } else {\n        entry.type = 'STATEMENT';\n        blockInfoList.push(entry);\n      }\n    }\n    return blockInfoList;\n  }\n  evaluateExpression(expression) {\n    expression = String(expression).trim();\n    const getValue = part => {\n      part = part.trim();\n      if (part === '') return {\n        success: false,\n        error: \"Malformed expression led to empty part.\"\n      };\n      if (/^\\d+$/.test(part)) return {\n        success: true,\n        value: Number(part)\n      };\n      if (part.startsWith('\"') && part.endsWith('\"')) return {\n        success: true,\n        value: part.slice(1, -1)\n      };\n      const varInfo = this.lookup(part);\n      if (varInfo === null) return {\n        success: false,\n        error: `Variable '${part}' not found`\n      };\n      if (varInfo.value === undefined) return {\n        success: false,\n        error: `Variable '${part}' was used before a value was assigned.`\n      };\n      return {\n        success: true,\n        value: varInfo.value\n      };\n    };\n    if (expression.startsWith('\"') && expression.endsWith('\"')) return getValue(expression);\n    const expressionRegex = /^\\s*(?<operand1>.+?)\\s*(?<operator>==|!=|<=|>=|<|>|\\+|-|\\*|\\/)\\s*(?<operand2>.+?)\\s*$/;\n    const match = expression.match(expressionRegex);\n    if (!match) return getValue(expression);\n    const {\n      operand1,\n      operator,\n      operand2\n    } = match.groups;\n    const leftResult = getValue(operand1);\n    if (!leftResult.success) return leftResult;\n    const rightResult = getValue(operand2);\n    if (!rightResult.success) return rightResult;\n    const leftVal = leftResult.value;\n    const rightVal = rightResult.value;\n    let resultValue;\n    switch (operator) {\n      case '+':\n        resultValue = leftVal + rightVal;\n        break;\n      case '-':\n        resultValue = leftVal - rightVal;\n        break;\n      case '*':\n        resultValue = leftVal * rightVal;\n        break;\n      case '/':\n        if (rightVal === 0) return {\n          success: false,\n          error: \"Division by zero\"\n        };\n        resultValue = Math.floor(leftVal / rightVal);\n        break;\n      case '==':\n        resultValue = leftVal == rightVal;\n        break;\n      case '!=':\n        resultValue = leftVal != rightVal;\n        break;\n      case '>':\n        resultValue = leftVal > rightVal;\n        break;\n      case '<':\n        resultValue = leftVal < rightVal;\n        break;\n      case '>=':\n        resultValue = leftVal >= rightVal;\n        break;\n      case '<=':\n        resultValue = leftVal <= rightVal;\n        break;\n      default:\n        return {\n          success: false,\n          error: `Unknown operator '${operator}'`\n        };\n    }\n    return {\n      success: true,\n      value: resultValue\n    };\n  }\n  executeStatement(line, inputList, inputIndexRef) {\n    let result = {\n      success: true\n    };\n    if (line.startsWith('PADAM')) {\n      const res = this.validatePadam(line);\n      if (res.status !== 'VALID') return {\n        success: false,\n        error: res.error\n      };\n      let finalValue = res.data.value;\n      if (finalValue !== undefined) {\n        const evalResult = this.evaluateExpression(finalValue);\n        if (!evalResult.success) return evalResult;\n        finalValue = evalResult.value;\n      }\n      result = this.declare(res.data.variable, {\n        type: res.data.type,\n        value: finalValue\n      });\n    } else if (line.startsWith('CHATIMPU')) {\n      const res = this.validateChatimpu(line);\n      if (res.status !== 'VALID') return {\n        success: false,\n        error: res.error\n      };\n      const arg = res.data.value || res.data.name;\n      const evalResult = this.evaluateExpression(arg);\n      if (!evalResult.success) return evalResult;\n      this.output.push(String(evalResult.value));\n    } else if (line.startsWith('CHEPPU')) {\n      const res = this.validateCheppu(line);\n      if (res.status !== 'VALID') return {\n        success: false,\n        error: res.error\n      };\n      const varName = res.data.variable;\n      if (inputIndexRef.value >= inputList.length) return {\n        success: false,\n        error: \"Not enough inputs provided\"\n      };\n      const inputVal = inputList[inputIndexRef.value++];\n      const varInfo = this.lookup(varName);\n      result = this.update(varName, varInfo.type === 'ANKHE' ? Number(inputVal) : String(inputVal));\n    } else if (line.includes('=')) {\n      const varName = line.split('=')[0].trim();\n      const expression = line.split('=')[1].replace(';', '').trim();\n      const evalResult = this.evaluateExpression(expression);\n      if (!evalResult.success) return evalResult;\n      result = this.update(varName, evalResult.value);\n    }\n    return result;\n  }\n  execute(blueprint, inputList, inputIndexRef, startIndex = 0, endIndex = blueprint.length) {\n    let pc = startIndex;\n    while (pc < endIndex) {\n      const command = blueprint[pc];\n      if (!command) {\n        pc++;\n        continue;\n      }\n      const line = command.lineText;\n      let result = {\n        success: true\n      };\n      if (command.type === 'ELAITHE') {\n        this.enterScope();\n        const condition = line.substring(line.indexOf('(') + 1, line.lastIndexOf(')'));\n        const evalResult = this.evaluateExpression(condition);\n        if (!evalResult.success) return evalResult;\n        const ifBodyEnd = command.elseBodyStartLine !== null ? command.elseBodyStartLine : command.constructEndLine;\n        if (evalResult.value) {\n          result = this.execute(blueprint, inputList, inputIndexRef, pc + 1, ifBodyEnd);\n          if (!result.success) return result;\n        } else {\n          if (command.elseBodyStartLine !== null) {\n            result = this.execute(blueprint, inputList, inputIndexRef, command.elseBodyStartLine + 1, command.constructEndLine);\n            if (!result.success) return result;\n          }\n        }\n        this.exitScope();\n        pc = command.constructEndLine;\n      } else if (command.type === 'MALLI_MALLI') {\n        this.enterScope();\n        const header = line.substring(line.indexOf('(') + 1, line.lastIndexOf(')'));\n        const parts = header.split(';').map(p => p.trim());\n        const initRes = this.validatePadam(parts[0] + ';');\n        if (initRes.status !== 'VALID') return {\n          success: false,\n          error: `Invalid loop initialization`\n        };\n        this.declare(initRes.data.variable, {\n          type: initRes.data.type,\n          value: Number(initRes.data.value)\n        });\n        while (true) {\n          const condResult = this.evaluateExpression(parts[1]);\n          if (!condResult.success) return condResult;\n          if (!condResult.value) break;\n          result = this.execute(blueprint, inputList, inputIndexRef, pc + 1, command.constructEndLine);\n          if (!result.success) return result;\n          const updateResult = this.evaluateExpression(parts[2].split('=')[1].trim());\n          if (!updateResult.success) return updateResult;\n          this.update(parts[2].split('=')[0].trim(), updateResult.value);\n        }\n        this.exitScope();\n        pc = command.constructEndLine;\n      } else if (command.type !== 'ELSE' && command.type !== 'BLOCK_END') {\n        result = this.executeStatement(line, inputList, inputIndexRef);\n        if (!result.success) return {\n          ...result,\n          error: `${result.error} on line ${pc + 1}`\n        };\n      }\n      pc++;\n    }\n    return {\n      success: true\n    };\n  }\n  run(programString, inputs = []) {\n    this.scopeStack = [new Map()];\n    this.output = [];\n    const lines = programString.replace(/\\n/g, \"|\").split('|').map(line => line.trim()).filter(Boolean);\n    const blueprint = this.analyzeBlockStructure(lines);\n    const inputIndexRef = {\n      value: 0\n    };\n    const result = this.execute(blueprint, inputs, inputIndexRef);\n    if (result.success) {\n      return {\n        success: true,\n        output: this.output.join('\\n')\n      };\n    } else {\n      return {\n        success: false,\n        error: result.error,\n        output: this.output.join('\\n')\n      };\n    }\n  }\n}\nconst CompilerInterface = ({\n  user,\n  onLogout\n}) => {\n  _s();\n  const [code, setCode] = useState(`# Hello World program\nPADAM message:VARTTAI = \"Hello World\";\nCHATIMPU(message);`);\n  const [output, setOutput] = useState('');\n  const [isRunning, setIsRunning] = useState(false);\n  const runCode = async () => {\n    setIsRunning(true);\n\n    // First validate the code\n    const validator = new YantraBhashiValidator();\n    const validationResult = validator.validate(code);\n    let outputText = '';\n    let status = 'success';\n    let errors = [];\n    if (!validationResult.isValid) {\n      status = 'error';\n      errors = validationResult.errors;\n      outputText = 'Compilation Errors:\\n' + validationResult.errors.map(err => `Line ${err.line}: ${err.message}`).join('\\n');\n    } else {\n      outputText = 'Code compiled successfully!\\nOutput:\\n';\n\n      // Run the interpreter\n      const interpreter = new YantraBhashiInterpreter();\n      const executionResult = interpreter.run(code, []); // Empty array for inputs, you can modify this as needed\n\n      if (executionResult.success) {\n        outputText += executionResult.output || '(No output)';\n      } else {\n        status = 'runtime_error';\n        outputText += `Runtime Error: ${executionResult.error}`;\n        if (executionResult.output) {\n          outputText += `\\n\\nOutput before error:\\n${executionResult.output}`;\n        }\n      }\n    }\n    setOutput(outputText);\n    try {\n      // Call backend submit API\n      await fetch('http://localhost:4000/submit', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          userId: user.userId,\n          code,\n          status,\n          output: status === 'success' ? outputText : '',\n          errors\n        })\n      });\n    } catch (error) {\n      console.error('Error submitting code:', error);\n    }\n    setIsRunning(false);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"min-h-screen bg-gray-100\",\n    children: [/*#__PURE__*/_jsxDEV(Header, {\n      title: \"YantraBhashi Compiler\",\n      user: user,\n      onLogout: onLogout\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 351,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"flex h-screen\",\n      children: [/*#__PURE__*/_jsxDEV(CodeEditor, {\n        code: code,\n        setCode: setCode,\n        onRun: runCode,\n        isRunning: isRunning\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 357,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(OutputPanel, {\n        output: output\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 363,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 356,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 350,\n    columnNumber: 5\n  }, this);\n};\n_s(CompilerInterface, \"RQOknoAWJIQgUMoMoKgHlF+QG/U=\");\n_c = CompilerInterface;\nexport default CompilerInterface;\nvar _c;\n$RefreshReg$(_c, \"CompilerInterface\");","map":{"version":3,"names":["React","useState","Header","CodeEditor","OutputPanel","YantraBhashiValidator","mockAPI","jsxDEV","_jsxDEV","YantraBhashiInterpreter","constructor","scopeStack","Map","output","enterScope","push","exitScope","length","pop","declare","name","info","scope","has","success","error","set","lookup","i","get","update","value","validatePadam","line","match","trim","status","data","groups","validateChatimpu","arg","argument","startsWith","validateCheppu","analyzeBlockStructure","lines","blockInfoList","blockStack","entry","lineNumber","lineText","elseBodyStartLine","type","currentBlock","finishedBlock","constructEndLine","evaluateExpression","expression","String","getValue","part","test","Number","endsWith","slice","varInfo","undefined","expressionRegex","operand1","operator","operand2","leftResult","rightResult","leftVal","rightVal","resultValue","Math","floor","executeStatement","inputList","inputIndexRef","result","res","finalValue","evalResult","variable","varName","inputVal","includes","split","replace","execute","blueprint","startIndex","endIndex","pc","command","condition","substring","indexOf","lastIndexOf","ifBodyEnd","header","parts","map","p","initRes","condResult","updateResult","run","programString","inputs","filter","Boolean","join","CompilerInterface","user","onLogout","_s","code","setCode","setOutput","isRunning","setIsRunning","runCode","validator","validationResult","validate","outputText","errors","isValid","err","message","interpreter","executionResult","fetch","method","headers","body","JSON","stringify","userId","console","className","children","title","fileName","_jsxFileName","columnNumber","onRun","_c","$RefreshReg$"],"sources":["/home/batman/Desktop/NO_Brainer/YantraBhashi_Team_4_SSD/frontend/src/components/compiler/CompilerInterface.js"],"sourcesContent":["import React, { useState } from 'react';\nimport Header from '../common/Header';\nimport CodeEditor from './CodeEditor';\nimport OutputPanel from './OutputPanel';\nimport YantraBhashiValidator from '../../services/validator';\nimport mockAPI from '../../services/mockAPI';\nimport '../../styles/components.css';\n\n// Inline interpreter class\nclass YantraBhashiInterpreter {\n  constructor() {\n    this.scopeStack = [new Map()];\n    this.output = [];\n  }\n\n  enterScope() {\n    this.scopeStack.push(new Map());\n  }\n\n  exitScope() {\n    if (this.scopeStack.length > 1) {\n      this.scopeStack.pop();\n    }\n  }\n\n  declare(name, info) {\n    const scope = this.scopeStack[this.scopeStack.length - 1];\n    if (scope.has(name)) {\n      return { success: false, error: `Variable '${name}' already declared.` };\n    }\n    scope.set(name, info);\n    return { success: true };\n  }\n\n  lookup(name) {\n    for (let i = this.scopeStack.length - 1; i >= 0; i--) {\n      if (this.scopeStack[i].has(name)) {\n        return this.scopeStack[i].get(name);\n      }\n    }\n    return null;\n  }\n\n  update(name, value) {\n    for (let i = this.scopeStack.length - 1; i >= 0; i--) {\n      if (this.scopeStack[i].has(name)) {\n        const info = this.scopeStack[i].get(name);\n        info.value = value;\n        return { success: true };\n      }\n    }\n    return { success: false, error: `Variable '${name}' not found.` };\n  }\n\n  validatePadam(line) {\n    const match = line.trim().match(/^\\s*PADAM\\s+(?<variable>[a-zA-Z_]\\w*)\\s*:\\s*(?<type>ANKHE|VARTTAI)(?:\\s*=\\s*(?<value>.+))?\\s*;\\s*$/);\n    if (!match) return { status: 'INVALID_SYNTAX' };\n    return { status: 'VALID', data: match.groups };\n  }\n\n  validateChatimpu(line) {\n    const match = line.trim().match(/^\\s*CHATIMPU\\s*\\(\\s*(?<argument>.*)\\s*\\)\\s*;\\s*$/);\n    if (!match) return { status: 'INVALID_SYNTAX' };\n    const arg = match.groups.argument.trim();\n    return { status: 'VALID', data: arg.startsWith('\"') ? { value: arg } : { name: arg } };\n  }\n\n  validateCheppu(line) {\n    const match = line.trim().match(/^\\s*CHEPPU\\s*\\(\\s*(?<variable>[a-zA-Z_]\\w*)\\s*\\)\\s*;\\s*$/);\n    if (!match) return { status: 'INVALID_SYNTAX' };\n    return { status: 'VALID', data: match.groups };\n  }\n\n  analyzeBlockStructure(lines) {\n    const blockInfoList = [];\n    const blockStack = [];\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      const entry = {\n        lineNumber: i,\n        lineText: line,\n        elseBodyStartLine: null\n      };\n\n      if (line.startsWith('ELAITHE')) {\n        entry.type = 'ELAITHE';\n        blockInfoList.push(entry);\n        blockStack.push(entry);\n      } else if (line.startsWith('MALLI-MALLI')) {\n        entry.type = 'MALLI_MALLI';\n        blockInfoList.push(entry);\n        blockStack.push(entry);\n      } else if (line.startsWith('] ALAITHE [')) {\n        entry.type = 'ELSE';\n        blockInfoList.push(entry);\n        const currentBlock = blockStack[blockStack.length - 1];\n        if (currentBlock && currentBlock.type === 'ELAITHE') {\n          currentBlock.elseBodyStartLine = i;\n        }\n      } else if (line === ']') {\n        entry.type = 'BLOCK_END';\n        blockInfoList.push(entry);\n        if (blockStack.length > 0) {\n          const finishedBlock = blockStack.pop();\n          finishedBlock.constructEndLine = i;\n        }\n      } else {\n        entry.type = 'STATEMENT';\n        blockInfoList.push(entry);\n      }\n    }\n    return blockInfoList;\n  }\n\n  evaluateExpression(expression) {\n    expression = String(expression).trim();\n    const getValue = (part) => {\n      part = part.trim();\n      if (part === '') return { success: false, error: \"Malformed expression led to empty part.\" };\n      if (/^\\d+$/.test(part)) return { success: true, value: Number(part) };\n      if (part.startsWith('\"') && part.endsWith('\"')) return { success: true, value: part.slice(1, -1) };\n      const varInfo = this.lookup(part);\n      if (varInfo === null) return { success: false, error: `Variable '${part}' not found` };\n      if (varInfo.value === undefined) return { success: false, error: `Variable '${part}' was used before a value was assigned.` };\n      return { success: true, value: varInfo.value };\n    };\n\n    if (expression.startsWith('\"') && expression.endsWith('\"')) return getValue(expression);\n\n    const expressionRegex = /^\\s*(?<operand1>.+?)\\s*(?<operator>==|!=|<=|>=|<|>|\\+|-|\\*|\\/)\\s*(?<operand2>.+?)\\s*$/;\n    const match = expression.match(expressionRegex);\n    if (!match) return getValue(expression);\n\n    const { operand1, operator, operand2 } = match.groups;\n    const leftResult = getValue(operand1);\n    if (!leftResult.success) return leftResult;\n    const rightResult = getValue(operand2);\n    if (!rightResult.success) return rightResult;\n\n    const leftVal = leftResult.value;\n    const rightVal = rightResult.value;\n    let resultValue;\n\n    switch (operator) {\n      case '+': resultValue = leftVal + rightVal; break;\n      case '-': resultValue = leftVal - rightVal; break;\n      case '*': resultValue = leftVal * rightVal; break;\n      case '/':\n        if (rightVal === 0) return { success: false, error: \"Division by zero\" };\n        resultValue = Math.floor(leftVal / rightVal);\n        break;\n      case '==': resultValue = leftVal == rightVal; break;\n      case '!=': resultValue = leftVal != rightVal; break;\n      case '>': resultValue = leftVal > rightVal; break;\n      case '<': resultValue = leftVal < rightVal; break;\n      case '>=': resultValue = leftVal >= rightVal; break;\n      case '<=': resultValue = leftVal <= rightVal; break;\n      default: return { success: false, error: `Unknown operator '${operator}'` };\n    }\n    return { success: true, value: resultValue };\n  }\n\n  executeStatement(line, inputList, inputIndexRef) {\n    let result = { success: true };\n\n    if (line.startsWith('PADAM')) {\n      const res = this.validatePadam(line);\n      if (res.status !== 'VALID') return { success: false, error: res.error };\n      let finalValue = res.data.value;\n      if (finalValue !== undefined) {\n        const evalResult = this.evaluateExpression(finalValue);\n        if (!evalResult.success) return evalResult;\n        finalValue = evalResult.value;\n      }\n      result = this.declare(res.data.variable, { type: res.data.type, value: finalValue });\n    } else if (line.startsWith('CHATIMPU')) {\n      const res = this.validateChatimpu(line);\n      if (res.status !== 'VALID') return { success: false, error: res.error };\n      const arg = res.data.value || res.data.name;\n      const evalResult = this.evaluateExpression(arg);\n      if (!evalResult.success) return evalResult;\n      this.output.push(String(evalResult.value));\n    } else if (line.startsWith('CHEPPU')) {\n      const res = this.validateCheppu(line);\n      if (res.status !== 'VALID') return { success: false, error: res.error };\n      const varName = res.data.variable;\n      if (inputIndexRef.value >= inputList.length) return { success: false, error: \"Not enough inputs provided\" };\n      const inputVal = inputList[inputIndexRef.value++];\n      const varInfo = this.lookup(varName);\n      result = this.update(varName, varInfo.type === 'ANKHE' ? Number(inputVal) : String(inputVal));\n    } else if (line.includes('=')) {\n      const varName = line.split('=')[0].trim();\n      const expression = line.split('=')[1].replace(';', '').trim();\n      const evalResult = this.evaluateExpression(expression);\n      if (!evalResult.success) return evalResult;\n      result = this.update(varName, evalResult.value);\n    }\n    return result;\n  }\n\n  execute(blueprint, inputList, inputIndexRef, startIndex = 0, endIndex = blueprint.length) {\n    let pc = startIndex;\n    while (pc < endIndex) {\n      const command = blueprint[pc];\n      if (!command) { pc++; continue; }\n\n      const line = command.lineText;\n      let result = { success: true };\n\n      if (command.type === 'ELAITHE') {\n        this.enterScope();\n        const condition = line.substring(line.indexOf('(') + 1, line.lastIndexOf(')'));\n        const evalResult = this.evaluateExpression(condition);\n        if (!evalResult.success) return evalResult;\n\n        const ifBodyEnd = command.elseBodyStartLine !== null ? command.elseBodyStartLine : command.constructEndLine;\n\n        if (evalResult.value) {\n          result = this.execute(blueprint, inputList, inputIndexRef, pc + 1, ifBodyEnd);\n          if (!result.success) return result;\n        } else {\n          if (command.elseBodyStartLine !== null) {\n            result = this.execute(blueprint, inputList, inputIndexRef, command.elseBodyStartLine + 1, command.constructEndLine);\n            if (!result.success) return result;\n          }\n        }\n        this.exitScope();\n        pc = command.constructEndLine;\n      } else if (command.type === 'MALLI_MALLI') {\n        this.enterScope();\n        const header = line.substring(line.indexOf('(') + 1, line.lastIndexOf(')'));\n        const parts = header.split(';').map(p => p.trim());\n        const initRes = this.validatePadam(parts[0] + ';');\n        if (initRes.status !== 'VALID') return { success: false, error: `Invalid loop initialization` };\n        this.declare(initRes.data.variable, { type: initRes.data.type, value: Number(initRes.data.value) });\n\n        while (true) {\n          const condResult = this.evaluateExpression(parts[1]);\n          if (!condResult.success) return condResult;\n          if (!condResult.value) break;\n\n          result = this.execute(blueprint, inputList, inputIndexRef, pc + 1, command.constructEndLine);\n          if (!result.success) return result;\n\n          const updateResult = this.evaluateExpression(parts[2].split('=')[1].trim());\n          if (!updateResult.success) return updateResult;\n          this.update(parts[2].split('=')[0].trim(), updateResult.value);\n        }\n        this.exitScope();\n        pc = command.constructEndLine;\n      } else if (command.type !== 'ELSE' && command.type !== 'BLOCK_END') {\n        result = this.executeStatement(line, inputList, inputIndexRef);\n        if (!result.success) return { ...result, error: `${result.error} on line ${pc + 1}` };\n      }\n\n      pc++;\n    }\n    return { success: true };\n  }\n\n  run(programString, inputs = []) {\n    this.scopeStack = [new Map()];\n    this.output = [];\n\n    const lines = programString.replace(/\\n/g, \"|\").split('|').map(line => line.trim()).filter(Boolean);\n    const blueprint = this.analyzeBlockStructure(lines);\n    const inputIndexRef = { value: 0 };\n\n    const result = this.execute(blueprint, inputs, inputIndexRef);\n\n    if (result.success) {\n      return {\n        success: true,\n        output: this.output.join('\\n')\n      };\n    } else {\n      return {\n        success: false,\n        error: result.error,\n        output: this.output.join('\\n')\n      };\n    }\n  }\n}\n\nconst CompilerInterface = ({ user, onLogout }) => {\n  const [code, setCode] = useState(`# Hello World program\nPADAM message:VARTTAI = \"Hello World\";\nCHATIMPU(message);`);\n  const [output, setOutput] = useState('');\n  const [isRunning, setIsRunning] = useState(false);\n\n  const runCode = async () => {\n    setIsRunning(true);\n\n    // First validate the code\n    const validator = new YantraBhashiValidator();\n    const validationResult = validator.validate(code);\n\n    let outputText = '';\n    let status = 'success';\n    let errors = [];\n\n    if (!validationResult.isValid) {\n      status = 'error';\n      errors = validationResult.errors;\n      outputText = 'Compilation Errors:\\n' + validationResult.errors.map(err => `Line ${err.line}: ${err.message}`).join('\\n');\n    } else {\n      outputText = 'Code compiled successfully!\\nOutput:\\n';\n\n      // Run the interpreter\n      const interpreter = new YantraBhashiInterpreter();\n      const executionResult = interpreter.run(code, []); // Empty array for inputs, you can modify this as needed\n\n      if (executionResult.success) {\n        outputText += executionResult.output || '(No output)';\n      } else {\n        status = 'runtime_error';\n        outputText += `Runtime Error: ${executionResult.error}`;\n        if (executionResult.output) {\n          outputText += `\\n\\nOutput before error:\\n${executionResult.output}`;\n        }\n      }\n    }\n\n    setOutput(outputText);\n\n    try {\n      // Call backend submit API\n      await fetch('http://localhost:4000/submit', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          userId: user.userId,\n          code,\n          status,\n          output: status === 'success' ? outputText : '',\n          errors,\n        }),\n      });\n    } catch (error) {\n      console.error('Error submitting code:', error);\n    }\n\n    setIsRunning(false);\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-100\">\n      <Header\n        title=\"YantraBhashi Compiler\"\n        user={user}\n        onLogout={onLogout}\n      />\n      <div className=\"flex h-screen\">\n        <CodeEditor\n          code={code}\n          setCode={setCode}\n          onRun={runCode}\n          isRunning={isRunning}\n        />\n        <OutputPanel output={output} />\n      </div>\n    </div>\n  );\n};\n\nexport default CompilerInterface;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}