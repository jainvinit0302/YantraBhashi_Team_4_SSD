{"ast":null,"code":"class YantraBhashiValidator {\n  constructor() {\n    this.variables = new Map();\n    this.errors = [];\n    this.reservedWords = [\n      // Add your reserved words here if any\n    ];\n    this.DATA_TYPES = ['ANKHE', 'VARTTAI'];\n\n    // Enhanced properties for scope management\n    this.scopeStack = [new Map()];\n    this.bracketStack = [];\n  }\n  preprocessCode(code) {\n    // Convert newlines to pipe separators if needed\n    const pipeFormatted = code.replace(/\\n/g, '|');\n    return this.tokenize(pipeFormatted, '|').map(line => line.trim()).filter(line => line && !line.startsWith('#')).map(line => line.replace(/^\\d+\\.\\s*/, '')); // Strip line numbers like \"1. \"\n  }\n  tokenize(input, delimiter) {\n    let tokens = [];\n    let left = 0;\n    let right = 0;\n    while (left < input.length) {\n      if (left === right && input[left] === delimiter) {\n        left++;\n        continue;\n      }\n      right = left + 1;\n      while (right < input.length && input[right] !== delimiter) {\n        right++;\n      }\n      tokens.push(input.substring(left, right));\n      left = right;\n    }\n    return tokens;\n  }\n  validate(code) {\n    // Reset state\n    this.variables.clear();\n    this.errors = [];\n    this.scopeStack = [new Map()];\n    this.bracketStack = [];\n    const lines = this.preprocessCode(code);\n    let isValid = true;\n    for (let i = 0; i < lines.length; i++) {\n      const result = this.validateLine(lines[i], i + 1);\n      if (result.status !== 'next') {\n        this.addError(i + 1, result.error);\n        isValid = false;\n      }\n    }\n\n    // Check for unclosed blocks\n    if (isValid && this.bracketStack.length !== 0) {\n      this.addError(-1, \"Unclosed block. Missing one or more ']' characters.\");\n      isValid = false;\n    }\n    return {\n      isValid: this.errors.length === 0,\n      errors: this.errors\n    };\n  }\n  validateLine(line, lineNum) {\n    const validationOrder = [this.validatePadam.bind(this), this.validateCheppu.bind(this), this.validateChatimpu.bind(this), this.validateElaitheHeader.bind(this), this.validateMalliMalliHeader.bind(this), this.validateBlockEnd.bind(this), this.validateAssignment.bind(this)];\n    for (const validator of validationOrder) {\n      const result = validator(line);\n      if (result.status === \"VALID\") {\n        // Handle scope management for different statement types\n        if (validator === this.validateElaitheHeader.bind(this)) {\n          this.enterScope();\n          this.bracketStack.push(1);\n        } else if (validator === this.validateMalliMalliHeader.bind(this)) {\n          this.enterScope();\n          const declareResult = this.declare(result.data.variable, {\n            type: result.data.type,\n            value: result.data.value\n          });\n          if (!declareResult.success) {\n            return {\n              status: 'SEMANTIC_ERROR',\n              error: declareResult.error\n            };\n          }\n          this.bracketStack.push(3);\n        } else if (validator === this.validateBlockEnd.bind(this)) {\n          if (this.bracketStack.length === 0) {\n            return {\n              status: \"Error\",\n              error: \"Closing bracket ']' has no matching opening block.\"\n            };\n          }\n          this.exitScope();\n          if (result.data.type === \"end_with_else\") {\n            this.enterScope();\n            if (this.bracketStack.length === 0 || this.bracketStack.pop() !== 1) {\n              return {\n                status: \"Error\",\n                error: \"'ALAITHE' must follow an 'ELAITHE' block.\"\n              };\n            }\n            this.bracketStack.push(2);\n          } else {\n            this.bracketStack.pop();\n          }\n        } else if (validator === this.validatePadam.bind(this)) {\n          const declareResult = this.declare(result.data.variable, {\n            type: result.data.type,\n            value: result.data.value\n          });\n          if (!declareResult.success) {\n            return {\n              status: 'SEMANTIC_ERROR',\n              error: declareResult.error\n            };\n          }\n        }\n        return {\n          status: \"next\"\n        };\n      }\n\n      // Handle semantic errors for block-opening statements\n      if (result.status === \"SEMANTIC_ERROR\") {\n        if (validator === this.validateElaitheHeader.bind(this) || validator === this.validateMalliMalliHeader.bind(this)) {\n          this.enterScope();\n          if (validator === this.validateElaitheHeader.bind(this)) {\n            this.bracketStack.push(1);\n          } else {\n            this.bracketStack.push(3);\n          }\n        }\n        return result;\n      }\n      if (result.status === \"INVALID_SYNTAX\") {\n        return result;\n      }\n    }\n    return {\n      status: \"Error\",\n      error: \"Invalid or unrecognized syntax\"\n    };\n  }\n\n  // Scope management methods\n  enterScope() {\n    this.scopeStack.push(new Map());\n  }\n  exitScope() {\n    if (this.scopeStack.length > 1) {\n      this.scopeStack.pop();\n    }\n  }\n  declare(variableName, info) {\n    const currentScope = this.scopeStack[this.scopeStack.length - 1];\n    if (currentScope.has(variableName)) {\n      return {\n        success: false,\n        error: `Variable '${variableName}' has already been declared in this scope.`\n      };\n    }\n    currentScope.set(variableName, info);\n    return {\n      success: true\n    };\n  }\n  lookup(variableName) {\n    for (let i = this.scopeStack.length - 1; i >= 0; i--) {\n      if (this.scopeStack[i].has(variableName)) {\n        return this.scopeStack[i].get(variableName);\n      }\n    }\n    return null;\n  }\n\n  // Utility methods\n  hasSemicolon(line) {\n    if (typeof line !== 'string') {\n      return false;\n    }\n    return line.trim().endsWith(';');\n  }\n  getExpressionType(expression) {\n    const trimmedExpr = expression.trim();\n    if (/^\\d+$/.test(trimmedExpr)) return {\n      success: true,\n      type: 'ANKHE'\n    };\n    if (/^\"[^\"]*\"?$/.test(trimmedExpr)) return {\n      success: true,\n      type: 'VARTTAI'\n    };\n    const variableInfo = this.lookup(trimmedExpr);\n    if (variableInfo) return {\n      success: true,\n      type: variableInfo.type\n    };\n    return {\n      success: false,\n      error: `Variable '${trimmedExpr}' was used before it was declared.`\n    };\n  }\n\n  // Validation methods for different statement types\n  validatePadam(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith('PADAM ')) {\n      return {\n        status: 'NOT_PADAM'\n      };\n    }\n    const padamRegex = /^\\s*PADAM\\s+(?<variable>[a-zA-Z_]\\w*)\\s*:\\s*(?<type>ANKHE|VARTTAI)(?:\\s*=\\s*(?<value>\\d+|\"[^\"]*\"))?\\s*;\\s*$/;\n    const match = trimmedLine.match(padamRegex);\n    if (!match) {\n      if (!this.hasSemicolon(line)) {\n        return {\n          status: 'INVALID_SYNTAX',\n          error: \"Missing semicolon (;) at the end of the PADAM statement.\"\n        };\n      }\n      return {\n        status: 'INVALID_SYNTAX',\n        error: \"Syntax error in PADAM declaration.\"\n      };\n    }\n    const {\n      variable,\n      type,\n      value\n    } = match.groups;\n    if (value !== undefined) {\n      const isStringValue = value.startsWith('\"');\n      if (type === 'ANKHE' && isStringValue) {\n        return {\n          status: 'SEMANTIC_ERROR',\n          error: `Type Mismatch: Cannot assign a VARTTAI (string) to an ANKHE (integer) variable '${variable}'.`\n        };\n      }\n      if (type === 'VARTTAI' && !isStringValue) {\n        return {\n          status: 'SEMANTIC_ERROR',\n          error: `Type Mismatch: Cannot assign an ANKHE (integer) to a VARTTAI (string) variable '${variable}'.`\n        };\n      }\n      return {\n        status: 'VALID',\n        type: 'initialization',\n        data: {\n          variable,\n          type,\n          value\n        }\n      };\n    } else {\n      return {\n        status: 'VALID',\n        type: 'declaration',\n        data: {\n          variable,\n          type,\n          value: undefined\n        }\n      };\n    }\n  }\n  validateCheppu(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith('CHEPPU')) {\n      return {\n        status: 'NOT_CHEPPU'\n      };\n    }\n    const cheppuRegex = /^\\s*CHEPPU\\s*\\(\\s*(?<variable>[a-zA-Z_]\\w*)\\s*\\)\\s*;\\s*$/;\n    const match = trimmedLine.match(cheppuRegex);\n    if (!match) {\n      if (!this.hasSemicolon(line)) {\n        return {\n          status: 'INVALID_SYNTAX',\n          error: \"Missing semicolon (;) at the end of the CHEPPU statement.\"\n        };\n      }\n      return {\n        status: 'INVALID_SYNTAX',\n        error: \"Syntax error in CHEPPU statement. Expected format: CHEPPU(variable);\"\n      };\n    }\n    const {\n      variable\n    } = match.groups;\n    const variableInfo = this.lookup(variable);\n    if (variableInfo === null) {\n      return {\n        status: 'SEMANTIC_ERROR',\n        error: `Undeclared Variable: Cannot get input for '${variable}' because it has not been declared.`\n      };\n    }\n    return {\n      status: 'VALID',\n      data: {\n        command: 'CHEPPU',\n        variable: variable\n      }\n    };\n  }\n  validateChatimpu(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith('CHATIMPU')) {\n      return {\n        status: 'NOT_CHATIMPU'\n      };\n    }\n    const chatimpuRegex = /^\\s*CHATIMPU\\s*\\(\\s*(?<argument>\"(?:\\\\.|[^\"\\\\])*\"|[a-zA-Z_]\\w*)\\s*\\)\\s*;\\s*$/;\n    const match = trimmedLine.match(chatimpuRegex);\n    if (!match) {\n      if (!this.hasSemicolon(line)) {\n        return {\n          status: 'INVALID_SYNTAX',\n          error: \"Missing semicolon (;) at the end of the CHATIMPU statement.\"\n        };\n      }\n      return {\n        status: 'INVALID_SYNTAX',\n        error: \"Syntax error in CHATIMPU. Expected format: CHATIMPU(variable_or_literal);\"\n      };\n    }\n    const {\n      argument\n    } = match.groups;\n    if (argument.startsWith('\"')) {\n      return {\n        status: 'VALID',\n        data: {\n          type: 'literal',\n          value: argument\n        }\n      };\n    } else {\n      if (this.lookup(argument) === null) {\n        return {\n          status: 'SEMANTIC_ERROR',\n          error: `Undeclared Variable: Cannot print '${argument}' because it has not been declared.`\n        };\n      }\n      return {\n        status: 'VALID',\n        data: {\n          type: 'variable',\n          name: argument\n        }\n      };\n    }\n  }\n  validateElaitheHeader(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith('ELAITHE')) {\n      return {\n        status: 'NOT_ELAITHE'\n      };\n    }\n    const headerRegex = /^\\s*ELAITHE\\s*\\(\\s*(?<operand1>\\S+)\\s*(?<operator>==|!=|<=|>=|<|>)\\s*(?<operand2>\\S+)\\s*\\)\\s*\\[\\s*$/;\n    const match = trimmedLine.match(headerRegex);\n    if (!match) {\n      return {\n        status: 'INVALID_SYNTAX',\n        error: \"Syntax error in ELAITHE header. Expected: ELAITHE (value operator value) [\"\n      };\n    }\n    const {\n      operand1,\n      operator,\n      operand2\n    } = match.groups;\n    const op1Result = this.getExpressionType(operand1);\n    const op2Result = this.getExpressionType(operand2);\n    if (!op1Result.success) return {\n      status: 'SEMANTIC_ERROR',\n      error: op1Result.error\n    };\n    if (!op2Result.success) return {\n      status: 'SEMANTIC_ERROR',\n      error: op2Result.error\n    };\n    if (op1Result.type !== op2Result.type) {\n      return {\n        status: 'SEMANTIC_ERROR',\n        error: `Type Mismatch: Cannot compare type ${op1Result.type} with type ${op2Result.type} in condition.`\n      };\n    }\n    return {\n      status: 'VALID'\n    };\n  }\n  validateMalliMalliHeader(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith('MALLI-MALLI')) {\n      return {\n        status: 'NOT_MALLI_MALLI'\n      };\n    }\n    const mainRegex = /^\\s*MALLI-MALLI\\s*\\((?<content>.*)\\)\\s*\\[\\s*$/;\n    const mainMatch = trimmedLine.match(mainRegex);\n    if (!mainMatch) {\n      return {\n        status: 'INVALID_SYNTAX',\n        error: \"Malformed MALLI-MALLI structure. Expected: MALLI-MALLI (...) [\"\n      };\n    }\n    const parts = mainMatch.groups.content.split(';').map(p => p.trim());\n    if (parts.length !== 3) {\n      return {\n        status: 'INVALID_SYNTAX',\n        error: \"MALLI-MALLI loop requires three parts: initialization; condition; update.\"\n      };\n    }\n    const initPart = parts[0];\n    const padamRegex = /^\\s*PADAM\\s+(?<variable>[a-zA-Z_]\\w*)\\s*:\\s*(?<type>ANKHE)\\s*=\\s*(?<value>\\d+)\\s*$/;\n    const initMatch = initPart.match(padamRegex);\n    if (!initMatch) {\n      return {\n        status: 'SEMANTIC_ERROR',\n        error: \"Loop initialization must be a PADAM statement initializing an ANKHE variable (e.g., PADAM i:ANKHE = 0).\"\n      };\n    }\n    const loopVarInfo = initMatch.groups;\n    const loopVariableName = loopVarInfo.variable;\n\n    // Internal lookup for loop variable validation\n    const internalLookup = varName => {\n      if (varName === loopVariableName) return {\n        type: 'ANKHE'\n      };\n      return this.lookup(varName);\n    };\n    const determineType = expr => {\n      if (/^\\d+$/.test(expr.trim())) return {\n        success: true,\n        type: 'ANKHE'\n      };\n      const result = internalLookup(expr.trim());\n      if (result) return {\n        success: true,\n        type: result.type\n      };\n      return {\n        success: false,\n        error: `Undeclared variable '${expr}' in loop condition.`\n      };\n    };\n\n    // Validate condition\n    const condPart = parts[1];\n    const condRegex = /^\\s*(?<op1>\\S+)\\s*(?<op>==|!=|<=|>=|<|>)\\s*(?<op2>\\S+)\\s*$/;\n    const condMatch = condPart.match(condRegex);\n    if (!condMatch) return {\n      status: 'INVALID_SYNTAX',\n      error: `Malformed loop condition: \"${condPart}\".`\n    };\n    const op1Result = determineType(condMatch.groups.op1);\n    const op2Result = determineType(condMatch.groups.op2);\n    if (!op1Result.success) return {\n      status: 'SEMANTIC_ERROR',\n      error: op1Result.error\n    };\n    if (!op2Result.success) return {\n      status: 'SEMANTIC_ERROR',\n      error: op2Result.error\n    };\n    if (op1Result.type !== 'ANKHE' || op2Result.type !== 'ANKHE') {\n      return {\n        status: 'SEMANTIC_ERROR',\n        error: `Loop condition must compare two ANKHE types.`\n      };\n    }\n\n    // Validate update\n    const updatePart = parts[2];\n    const updateRegex = /^\\s*(?<lhs>\\S+)\\s*=\\s*(?<rhs>\\S+)\\s*([+-])\\s*1\\s*$/;\n    const updateMatch = updatePart.match(updateRegex);\n    if (!updateMatch || updateMatch.groups.lhs !== loopVariableName || updateMatch.groups.rhs !== loopVariableName) {\n      return {\n        status: 'SEMANTIC_ERROR',\n        error: `Loop update must be of the form '${loopVariableName} = ${loopVariableName} + 1'.`\n      };\n    }\n    return {\n      status: 'VALID',\n      data: {\n        variable: loopVarInfo.variable,\n        type: loopVarInfo.type,\n        value: loopVarInfo.value\n      }\n    };\n  }\n  validateBlockEnd(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith(']')) {\n      return {\n        status: 'NOT_A_BLOCK_END'\n      };\n    }\n    const elseRegex = /^\\s*]\\s*ALAITHE\\s*\\[\\s*$/;\n    if (elseRegex.test(trimmedLine)) {\n      return {\n        status: 'VALID',\n        data: {\n          type: 'end_with_else'\n        }\n      };\n    }\n    const endOnlyRegex = /^\\s*]\\s*$/;\n    if (endOnlyRegex.test(trimmedLine)) {\n      return {\n        status: 'VALID',\n        data: {\n          type: 'end_only'\n        }\n      };\n    }\n    return {\n      status: 'INVALID_SYNTAX',\n      error: \"Malformed block-closing statement. Expected ']' or '] ALAITHE ['.\"\n    };\n  }\n  validateAssignment(line) {\n    const trimmedLine = line.trim();\n    if (!/(?<![=<>!])=(?![=])/.test(trimmedLine)) {\n      return {\n        status: 'NOT_ASSIGNMENT'\n      };\n    }\n    const assignRegex = /^\\s*(?<lhsVar>[a-zA-Z_]\\w*)\\s*=\\s*(?<rhsExpr>.*);\\s*$/;\n    const match = trimmedLine.match(assignRegex);\n    if (!match) {\n      if (!this.hasSemicolon(line)) {\n        return {\n          status: 'INVALID_SYNTAX',\n          error: \"Missing semicolon (;) at the end of the assignment statement.\"\n        };\n      }\n      return {\n        status: 'INVALID_SYNTAX',\n        error: \"Invalid syntax for assignment statement.\"\n      };\n    }\n    const {\n      lhsVar,\n      rhsExpr\n    } = match.groups;\n    const lhsInfo = this.lookup(lhsVar);\n    if (!lhsInfo) {\n      return {\n        status: 'SEMANTIC_ERROR',\n        error: `Undeclared variable '${lhsVar}' used in assignment.`\n      };\n    }\n    let rhsType;\n    const operators = ['+', '-', '*', '/'];\n    const foundOperator = operators.find(op => rhsExpr.includes(op));\n    if (foundOperator) {\n      const parts = rhsExpr.split(foundOperator);\n      if (parts.length !== 2) {\n        return {\n          status: 'INVALID_SYNTAX',\n          error: 'Malformed expression. Only simple binary operations are supported.'\n        };\n      }\n      const leftResult = this.getExpressionType(parts[0]);\n      const rightResult = this.getExpressionType(parts[1]);\n      if (!leftResult.success) return {\n        status: 'SEMANTIC_ERROR',\n        error: leftResult.error\n      };\n      if (!rightResult.success) return {\n        status: 'SEMANTIC_ERROR',\n        error: rightResult.error\n      };\n      if (leftResult.type === 'ANKHE' && rightResult.type === 'ANKHE') {\n        rhsType = 'ANKHE';\n      } else {\n        return {\n          status: 'SEMANTIC_ERROR',\n          error: `Type Mismatch: Operator '${foundOperator}' can only be used between two ANKHE types.`\n        };\n      }\n    } else {\n      const result = this.getExpressionType(rhsExpr);\n      if (!result.success) return {\n        status: 'SEMANTIC_ERROR',\n        error: result.error\n      };\n      rhsType = result.type;\n    }\n    if (lhsInfo.type !== rhsType) {\n      return {\n        status: 'SEMANTIC_ERROR',\n        error: `Type Mismatch: Cannot assign a value of type ${rhsType} to variable '${lhsVar}' of type ${lhsInfo.type}.`\n      };\n    }\n    return {\n      status: 'VALID'\n    };\n  }\n  addError(lineNum, message) {\n    this.errors.push({\n      line: lineNum,\n      message\n    });\n  }\n}\nexport default YantraBhashiValidator;","map":{"version":3,"names":["YantraBhashiValidator","constructor","variables","Map","errors","reservedWords","DATA_TYPES","scopeStack","bracketStack","preprocessCode","code","pipeFormatted","replace","tokenize","map","line","trim","filter","startsWith","input","delimiter","tokens","left","right","length","push","substring","validate","clear","lines","isValid","i","result","validateLine","status","addError","error","lineNum","validationOrder","validatePadam","bind","validateCheppu","validateChatimpu","validateElaitheHeader","validateMalliMalliHeader","validateBlockEnd","validateAssignment","validator","enterScope","declareResult","declare","data","variable","type","value","success","exitScope","pop","variableName","info","currentScope","has","set","lookup","get","hasSemicolon","endsWith","getExpressionType","expression","trimmedExpr","test","variableInfo","trimmedLine","padamRegex","match","groups","undefined","isStringValue","cheppuRegex","command","chatimpuRegex","argument","name","headerRegex","operand1","operator","operand2","op1Result","op2Result","mainRegex","mainMatch","parts","content","split","p","initPart","initMatch","loopVarInfo","loopVariableName","internalLookup","varName","determineType","expr","condPart","condRegex","condMatch","op1","op2","updatePart","updateRegex","updateMatch","lhs","rhs","elseRegex","endOnlyRegex","assignRegex","lhsVar","rhsExpr","lhsInfo","rhsType","operators","foundOperator","find","op","includes","leftResult","rightResult","message"],"sources":["/home/batman/Desktop/NO_Brainer/YantraBhashi_Team_4_SSD/frontend/src/services/validator.js"],"sourcesContent":["class YantraBhashiValidator {\n  constructor() {\n    this.variables = new Map();\n    this.errors = [];\n    this.reservedWords = [\n      // Add your reserved words here if any\n    ];\n    this.DATA_TYPES = ['ANKHE', 'VARTTAI'];\n\n    // Enhanced properties for scope management\n    this.scopeStack = [new Map()];\n    this.bracketStack = [];\n  }\n\n  preprocessCode(code) {\n    // Convert newlines to pipe separators if needed\n    const pipeFormatted = code.replace(/\\n/g, '|');\n\n    return this.tokenize(pipeFormatted, '|')\n      .map(line => line.trim())\n      .filter(line => line && !line.startsWith('#'))\n      .map(line => line.replace(/^\\d+\\.\\s*/, '')); // Strip line numbers like \"1. \"\n  }\n\n  tokenize(input, delimiter) {\n    let tokens = [];\n    let left = 0;\n    let right = 0;\n\n    while (left < input.length) {\n      if (left === right && input[left] === delimiter) {\n        left++;\n        continue;\n      }\n      right = left + 1;\n      while (right < input.length && input[right] !== delimiter) {\n        right++;\n      }\n      tokens.push(input.substring(left, right));\n      left = right;\n    }\n    return tokens;\n  }\n\n  validate(code) {\n    // Reset state\n    this.variables.clear();\n    this.errors = [];\n    this.scopeStack = [new Map()];\n    this.bracketStack = [];\n\n    const lines = this.preprocessCode(code);\n    let isValid = true;\n\n    for (let i = 0; i < lines.length; i++) {\n      const result = this.validateLine(lines[i], i + 1);\n      if (result.status !== 'next') {\n        this.addError(i + 1, result.error);\n        isValid = false;\n      }\n    }\n\n    // Check for unclosed blocks\n    if (isValid && this.bracketStack.length !== 0) {\n      this.addError(-1, \"Unclosed block. Missing one or more ']' characters.\");\n      isValid = false;\n    }\n\n    return {\n      isValid: this.errors.length === 0,\n      errors: this.errors,\n    };\n  }\n\n  validateLine(line, lineNum) {\n    const validationOrder = [\n      this.validatePadam.bind(this),\n      this.validateCheppu.bind(this),\n      this.validateChatimpu.bind(this),\n      this.validateElaitheHeader.bind(this),\n      this.validateMalliMalliHeader.bind(this),\n      this.validateBlockEnd.bind(this),\n      this.validateAssignment.bind(this)\n    ];\n\n    for (const validator of validationOrder) {\n      const result = validator(line);\n\n      if (result.status === \"VALID\") {\n        // Handle scope management for different statement types\n        if (validator === this.validateElaitheHeader.bind(this)) {\n          this.enterScope();\n          this.bracketStack.push(1);\n        } else if (validator === this.validateMalliMalliHeader.bind(this)) {\n          this.enterScope();\n          const declareResult = this.declare(result.data.variable, {\n            type: result.data.type,\n            value: result.data.value\n          });\n          if (!declareResult.success) {\n            return { status: 'SEMANTIC_ERROR', error: declareResult.error };\n          }\n          this.bracketStack.push(3);\n        } else if (validator === this.validateBlockEnd.bind(this)) {\n          if (this.bracketStack.length === 0) {\n            return { status: \"Error\", error: \"Closing bracket ']' has no matching opening block.\" };\n          }\n          this.exitScope();\n          if (result.data.type === \"end_with_else\") {\n            this.enterScope();\n            if (this.bracketStack.length === 0 || this.bracketStack.pop() !== 1) {\n              return { status: \"Error\", error: \"'ALAITHE' must follow an 'ELAITHE' block.\" };\n            }\n            this.bracketStack.push(2);\n          } else {\n            this.bracketStack.pop();\n          }\n        } else if (validator === this.validatePadam.bind(this)) {\n          const declareResult = this.declare(result.data.variable, {\n            type: result.data.type,\n            value: result.data.value\n          });\n          if (!declareResult.success) {\n            return { status: 'SEMANTIC_ERROR', error: declareResult.error };\n          }\n        }\n        return { status: \"next\" };\n      }\n\n      // Handle semantic errors for block-opening statements\n      if (result.status === \"SEMANTIC_ERROR\") {\n        if (validator === this.validateElaitheHeader.bind(this) ||\n          validator === this.validateMalliMalliHeader.bind(this)) {\n          this.enterScope();\n          if (validator === this.validateElaitheHeader.bind(this)) {\n            this.bracketStack.push(1);\n          } else {\n            this.bracketStack.push(3);\n          }\n        }\n        return result;\n      }\n\n      if (result.status === \"INVALID_SYNTAX\") {\n        return result;\n      }\n    }\n\n    return { status: \"Error\", error: \"Invalid or unrecognized syntax\" };\n  }\n\n  // Scope management methods\n  enterScope() {\n    this.scopeStack.push(new Map());\n  }\n\n  exitScope() {\n    if (this.scopeStack.length > 1) {\n      this.scopeStack.pop();\n    }\n  }\n\n  declare(variableName, info) {\n    const currentScope = this.scopeStack[this.scopeStack.length - 1];\n    if (currentScope.has(variableName)) {\n      return { success: false, error: `Variable '${variableName}' has already been declared in this scope.` };\n    }\n    currentScope.set(variableName, info);\n    return { success: true };\n  }\n\n  lookup(variableName) {\n    for (let i = this.scopeStack.length - 1; i >= 0; i--) {\n      if (this.scopeStack[i].has(variableName)) {\n        return this.scopeStack[i].get(variableName);\n      }\n    }\n    return null;\n  }\n\n  // Utility methods\n  hasSemicolon(line) {\n    if (typeof line !== 'string') {\n      return false;\n    }\n    return line.trim().endsWith(';');\n  }\n\n  getExpressionType(expression) {\n    const trimmedExpr = expression.trim();\n    if (/^\\d+$/.test(trimmedExpr)) return { success: true, type: 'ANKHE' };\n    if (/^\"[^\"]*\"?$/.test(trimmedExpr)) return { success: true, type: 'VARTTAI' };\n\n    const variableInfo = this.lookup(trimmedExpr);\n    if (variableInfo) return { success: true, type: variableInfo.type };\n\n    return { success: false, error: `Variable '${trimmedExpr}' was used before it was declared.` };\n  }\n\n  // Validation methods for different statement types\n  validatePadam(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith('PADAM ')) {\n      return { status: 'NOT_PADAM' };\n    }\n\n    const padamRegex = /^\\s*PADAM\\s+(?<variable>[a-zA-Z_]\\w*)\\s*:\\s*(?<type>ANKHE|VARTTAI)(?:\\s*=\\s*(?<value>\\d+|\"[^\"]*\"))?\\s*;\\s*$/;\n    const match = trimmedLine.match(padamRegex);\n\n    if (!match) {\n      if (!this.hasSemicolon(line)) {\n        return { status: 'INVALID_SYNTAX', error: \"Missing semicolon (;) at the end of the PADAM statement.\" };\n      }\n      return { status: 'INVALID_SYNTAX', error: \"Syntax error in PADAM declaration.\" };\n    }\n\n    const { variable, type, value } = match.groups;\n\n    if (value !== undefined) {\n      const isStringValue = value.startsWith('\"');\n      if (type === 'ANKHE' && isStringValue) {\n        return { status: 'SEMANTIC_ERROR', error: `Type Mismatch: Cannot assign a VARTTAI (string) to an ANKHE (integer) variable '${variable}'.` };\n      }\n      if (type === 'VARTTAI' && !isStringValue) {\n        return { status: 'SEMANTIC_ERROR', error: `Type Mismatch: Cannot assign an ANKHE (integer) to a VARTTAI (string) variable '${variable}'.` };\n      }\n      return { status: 'VALID', type: 'initialization', data: { variable, type, value } };\n    } else {\n      return { status: 'VALID', type: 'declaration', data: { variable, type, value: undefined } };\n    }\n  }\n\n  validateCheppu(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith('CHEPPU')) {\n      return { status: 'NOT_CHEPPU' };\n    }\n\n    const cheppuRegex = /^\\s*CHEPPU\\s*\\(\\s*(?<variable>[a-zA-Z_]\\w*)\\s*\\)\\s*;\\s*$/;\n    const match = trimmedLine.match(cheppuRegex);\n\n    if (!match) {\n      if (!this.hasSemicolon(line)) {\n        return { status: 'INVALID_SYNTAX', error: \"Missing semicolon (;) at the end of the CHEPPU statement.\" };\n      }\n      return { status: 'INVALID_SYNTAX', error: \"Syntax error in CHEPPU statement. Expected format: CHEPPU(variable);\" };\n    }\n\n    const { variable } = match.groups;\n    const variableInfo = this.lookup(variable);\n\n    if (variableInfo === null) {\n      return { status: 'SEMANTIC_ERROR', error: `Undeclared Variable: Cannot get input for '${variable}' because it has not been declared.` };\n    }\n\n    return { status: 'VALID', data: { command: 'CHEPPU', variable: variable } };\n  }\n\n  validateChatimpu(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith('CHATIMPU')) {\n      return { status: 'NOT_CHATIMPU' };\n    }\n\n    const chatimpuRegex = /^\\s*CHATIMPU\\s*\\(\\s*(?<argument>\"(?:\\\\.|[^\"\\\\])*\"|[a-zA-Z_]\\w*)\\s*\\)\\s*;\\s*$/;\n    const match = trimmedLine.match(chatimpuRegex);\n\n    if (!match) {\n      if (!this.hasSemicolon(line)) {\n        return { status: 'INVALID_SYNTAX', error: \"Missing semicolon (;) at the end of the CHATIMPU statement.\" };\n      }\n      return { status: 'INVALID_SYNTAX', error: \"Syntax error in CHATIMPU. Expected format: CHATIMPU(variable_or_literal);\" };\n    }\n\n    const { argument } = match.groups;\n\n    if (argument.startsWith('\"')) {\n      return { status: 'VALID', data: { type: 'literal', value: argument } };\n    } else {\n      if (this.lookup(argument) === null) {\n        return { status: 'SEMANTIC_ERROR', error: `Undeclared Variable: Cannot print '${argument}' because it has not been declared.` };\n      }\n      return { status: 'VALID', data: { type: 'variable', name: argument } };\n    }\n  }\n\n  validateElaitheHeader(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith('ELAITHE')) {\n      return { status: 'NOT_ELAITHE' };\n    }\n\n    const headerRegex = /^\\s*ELAITHE\\s*\\(\\s*(?<operand1>\\S+)\\s*(?<operator>==|!=|<=|>=|<|>)\\s*(?<operand2>\\S+)\\s*\\)\\s*\\[\\s*$/;\n    const match = trimmedLine.match(headerRegex);\n\n    if (!match) {\n      return { status: 'INVALID_SYNTAX', error: \"Syntax error in ELAITHE header. Expected: ELAITHE (value operator value) [\" };\n    }\n\n    const { operand1, operator, operand2 } = match.groups;\n    const op1Result = this.getExpressionType(operand1);\n    const op2Result = this.getExpressionType(operand2);\n\n    if (!op1Result.success) return { status: 'SEMANTIC_ERROR', error: op1Result.error };\n    if (!op2Result.success) return { status: 'SEMANTIC_ERROR', error: op2Result.error };\n\n    if (op1Result.type !== op2Result.type) {\n      return { status: 'SEMANTIC_ERROR', error: `Type Mismatch: Cannot compare type ${op1Result.type} with type ${op2Result.type} in condition.` };\n    }\n\n    return { status: 'VALID' };\n  }\n\n  validateMalliMalliHeader(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith('MALLI-MALLI')) {\n      return { status: 'NOT_MALLI_MALLI' };\n    }\n\n    const mainRegex = /^\\s*MALLI-MALLI\\s*\\((?<content>.*)\\)\\s*\\[\\s*$/;\n    const mainMatch = trimmedLine.match(mainRegex);\n\n    if (!mainMatch) {\n      return { status: 'INVALID_SYNTAX', error: \"Malformed MALLI-MALLI structure. Expected: MALLI-MALLI (...) [\" };\n    }\n\n    const parts = mainMatch.groups.content.split(';').map(p => p.trim());\n\n    if (parts.length !== 3) {\n      return { status: 'INVALID_SYNTAX', error: \"MALLI-MALLI loop requires three parts: initialization; condition; update.\" };\n    }\n\n    const initPart = parts[0];\n    const padamRegex = /^\\s*PADAM\\s+(?<variable>[a-zA-Z_]\\w*)\\s*:\\s*(?<type>ANKHE)\\s*=\\s*(?<value>\\d+)\\s*$/;\n    const initMatch = initPart.match(padamRegex);\n\n    if (!initMatch) {\n      return { status: 'SEMANTIC_ERROR', error: \"Loop initialization must be a PADAM statement initializing an ANKHE variable (e.g., PADAM i:ANKHE = 0).\" };\n    }\n\n    const loopVarInfo = initMatch.groups;\n    const loopVariableName = loopVarInfo.variable;\n\n    // Internal lookup for loop variable validation\n    const internalLookup = (varName) => {\n      if (varName === loopVariableName) return { type: 'ANKHE' };\n      return this.lookup(varName);\n    };\n\n    const determineType = (expr) => {\n      if (/^\\d+$/.test(expr.trim())) return { success: true, type: 'ANKHE' };\n      const result = internalLookup(expr.trim());\n      if (result) return { success: true, type: result.type };\n      return { success: false, error: `Undeclared variable '${expr}' in loop condition.` };\n    };\n\n    // Validate condition\n    const condPart = parts[1];\n    const condRegex = /^\\s*(?<op1>\\S+)\\s*(?<op>==|!=|<=|>=|<|>)\\s*(?<op2>\\S+)\\s*$/;\n    const condMatch = condPart.match(condRegex);\n\n    if (!condMatch) return { status: 'INVALID_SYNTAX', error: `Malformed loop condition: \"${condPart}\".` };\n\n    const op1Result = determineType(condMatch.groups.op1);\n    const op2Result = determineType(condMatch.groups.op2);\n\n    if (!op1Result.success) return { status: 'SEMANTIC_ERROR', error: op1Result.error };\n    if (!op2Result.success) return { status: 'SEMANTIC_ERROR', error: op2Result.error };\n\n    if (op1Result.type !== 'ANKHE' || op2Result.type !== 'ANKHE') {\n      return { status: 'SEMANTIC_ERROR', error: `Loop condition must compare two ANKHE types.` };\n    }\n\n    // Validate update\n    const updatePart = parts[2];\n    const updateRegex = /^\\s*(?<lhs>\\S+)\\s*=\\s*(?<rhs>\\S+)\\s*([+-])\\s*1\\s*$/;\n    const updateMatch = updatePart.match(updateRegex);\n\n    if (!updateMatch || updateMatch.groups.lhs !== loopVariableName || updateMatch.groups.rhs !== loopVariableName) {\n      return { status: 'SEMANTIC_ERROR', error: `Loop update must be of the form '${loopVariableName} = ${loopVariableName} + 1'.` };\n    }\n\n    return { status: 'VALID', data: { variable: loopVarInfo.variable, type: loopVarInfo.type, value: loopVarInfo.value } };\n  }\n\n  validateBlockEnd(line) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine.startsWith(']')) {\n      return { status: 'NOT_A_BLOCK_END' };\n    }\n\n    const elseRegex = /^\\s*]\\s*ALAITHE\\s*\\[\\s*$/;\n    if (elseRegex.test(trimmedLine)) {\n      return { status: 'VALID', data: { type: 'end_with_else' } };\n    }\n\n    const endOnlyRegex = /^\\s*]\\s*$/;\n    if (endOnlyRegex.test(trimmedLine)) {\n      return { status: 'VALID', data: { type: 'end_only' } };\n    }\n\n    return { status: 'INVALID_SYNTAX', error: \"Malformed block-closing statement. Expected ']' or '] ALAITHE ['.\" };\n  }\n\n  validateAssignment(line) {\n    const trimmedLine = line.trim();\n    if (!/(?<![=<>!])=(?![=])/.test(trimmedLine)) {\n      return { status: 'NOT_ASSIGNMENT' };\n    }\n\n    const assignRegex = /^\\s*(?<lhsVar>[a-zA-Z_]\\w*)\\s*=\\s*(?<rhsExpr>.*);\\s*$/;\n    const match = trimmedLine.match(assignRegex);\n\n    if (!match) {\n      if (!this.hasSemicolon(line)) {\n        return { status: 'INVALID_SYNTAX', error: \"Missing semicolon (;) at the end of the assignment statement.\" };\n      }\n      return { status: 'INVALID_SYNTAX', error: \"Invalid syntax for assignment statement.\" };\n    }\n\n    const { lhsVar, rhsExpr } = match.groups;\n    const lhsInfo = this.lookup(lhsVar);\n\n    if (!lhsInfo) {\n      return { status: 'SEMANTIC_ERROR', error: `Undeclared variable '${lhsVar}' used in assignment.` };\n    }\n\n    let rhsType;\n    const operators = ['+', '-', '*', '/'];\n    const foundOperator = operators.find(op => rhsExpr.includes(op));\n\n    if (foundOperator) {\n      const parts = rhsExpr.split(foundOperator);\n      if (parts.length !== 2) {\n        return { status: 'INVALID_SYNTAX', error: 'Malformed expression. Only simple binary operations are supported.' };\n      }\n\n      const leftResult = this.getExpressionType(parts[0]);\n      const rightResult = this.getExpressionType(parts[1]);\n\n      if (!leftResult.success) return { status: 'SEMANTIC_ERROR', error: leftResult.error };\n      if (!rightResult.success) return { status: 'SEMANTIC_ERROR', error: rightResult.error };\n\n      if (leftResult.type === 'ANKHE' && rightResult.type === 'ANKHE') {\n        rhsType = 'ANKHE';\n      } else {\n        return { status: 'SEMANTIC_ERROR', error: `Type Mismatch: Operator '${foundOperator}' can only be used between two ANKHE types.` };\n      }\n    } else {\n      const result = this.getExpressionType(rhsExpr);\n      if (!result.success) return { status: 'SEMANTIC_ERROR', error: result.error };\n      rhsType = result.type;\n    }\n\n    if (lhsInfo.type !== rhsType) {\n      return { status: 'SEMANTIC_ERROR', error: `Type Mismatch: Cannot assign a value of type ${rhsType} to variable '${lhsVar}' of type ${lhsInfo.type}.` };\n    }\n\n    return { status: 'VALID' };\n  }\n\n  addError(lineNum, message) {\n    this.errors.push({ line: lineNum, message });\n  }\n}\n\nexport default YantraBhashiValidator;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}